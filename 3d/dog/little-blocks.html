<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Рисуем собакена</title>
  <script src="https://threejs.org/build/three.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <script type="module">
    import { GLTFLoader } from 'https://threejs.org/examples/jsm/loaders/GLTFLoader.js'

let scene = new THREE.Scene()
let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 )

let renderer = new THREE.WebGLRenderer()
renderer.setSize( window.innerWidth * 0.9, window.innerHeight * 0.9 )
renderer.setClearColor( 0xffffff, 1 )
document.body.appendChild( renderer.domElement )
renderer.shadowMap.enabled = true
scene.add(new THREE.AmbientLight(0xffffff, 0.6))
let point_light = new THREE.PointLight(0xffffff, 0.5)
// let point_light = new THREE.DirectionalLight(0xffffff, 5)
point_light.position.set( -500, 700, 300 )
point_light.castShadow = true
point_light.shadow.camera.far = 5000
scene.add(point_light)

let tail = {
    points: [
	[344],
    ],
    delta: 0.2,
    init: function() {
	let g = window.dog
	let ind = g.index.array
	let pos = g.attributes.position.array
	function lp(base, prev) { // linked points
	    let next = []
	    for(let t = 0; t < g.index.count; t = t + 3) {
		if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
		    for(let i = t; i < t + 3; ++i) {
			let p = ind[i]
			if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
			    next.push(p)
		    }
	    }
	    next.sort((a,b)=>a-b)
	    return next
	}
	tail.points.push(lp(tail.points[tail.points.length-1], []))
	for(let i = 2; i < 14; ++i)
	    tail.points.push(lp(tail.points[tail.points.length-1],
				tail.points[tail.points.length-2]))
	tail.centers = tail.points.map(function(list) {
	    if(list.length == 0) return
	    else if(list.length == 1) {
		let a = list[0] * 3
		return Array.from(pos.slice(a, a + 3))
	    }
	    else {
		let s = [0,0,0]
		list.forEach(function(item) {
		    let a = item * 3
		    for(let i = 0; i < 3; ++i,++a) s[i] = s[i] + pos[a]
		})
		return s.map((v) => v / list.length)
	    }
	})
    },
    rotation_center: function(n) {
	function leg(a,b,c,d) {
	    return Math.pow(tail.centers[a][b] - tail.centers[c][d], 2)
	}
	let s0 = n * 2, s1 = s0+1
	let len0 = Math.sqrt(leg(s0, 0, s1, 0) +
			     leg(s0, 1, s1, 1) +
			     leg(s0, 2, s1, 2))
	// rc === Rotation Center
	let rc0 = []
	for(let i = 0; i < 3; ++i)
	    rc0[i] = tail.centers[s1][i] +
	    (tail.centers[s1][i] - tail.centers[s0][i]) * tail.delta / len0
	return rc0	
    },
}

let loader = new GLTFLoader()
loader.load('little-blocks-conv.glb', function(gltf) {
    console.log(gltf)
    let mesh = gltf.scene.children[0]
    mesh.scale.set(10, 10, 10)
    let material = new THREE.MeshStandardMaterial({ color: 0x97612f })
    let material_red = new THREE.MeshStandardMaterial({ color: 0xff0000 })
    mesh.material = [material, material_red]
    mesh.geometry.addGroup(0, 1620, 0)
    mesh.geometry.addGroup(1620, 24, 1)
    mesh.geometry.addGroup(1644, 960, 0)
    scene.add(mesh)
    window.dog = mesh.geometry
    tail.init()
})

camera.position.set(-30, 0, 100)
let controls = new THREE.OrbitControls( camera, renderer.domElement )

function animate() {
    requestAnimationFrame( animate )
    renderer.render( scene, camera )
}
animate()

window.correct_tail = function() {
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    function leg(a,b,c,d) {
	return Math.pow(tail.centers[a][b] - tail.centers[c][d], 2)
    }
    function check_segment(n) {
	let s0 = n * 2, s1 = s0+1, s2 = s0+2, s3 = s0+3
	let len0 = Math.sqrt(leg(s0, 0, s1, 0) +
			     leg(s0, 1, s1, 1) +
			     leg(s0, 2, s1, 2))
	let len1 = Math.sqrt(leg(s2, 0, s3, 0) +
			     leg(s2, 1, s3, 1) +
			     leg(s2, 2, s3, 2))
	// rp === Rotation Center
	let rc0 = []
	for(let i = 0; i < 3; ++i)
	    rc0[i] = tail.centers[s1][i] +
	    (tail.centers[s1][i] - tail.centers[s0][i]) * tail.delta / len0
	let rc0a = []
	for(let i = 0; i < 3; ++i)
	    rc0a[i] = tail.centers[s2][i] -
	    (tail.centers[s3][i] - tail.centers[s2][i]) * tail.delta / len1
	let m = []
	for(let i = 0; i < 3; ++i) m[i] = rc0a[i] - rc0[i]
	return m
    }
    function mp(m, c) { // Move Points
	// console.log(m)
	for(let a = 0; a < c; ++a)
	    for(let b = 0; b < tail.points[a].length; ++b) {
		let p = tail.points[a][b] * 3
		for(let i = 0; i < 3; ++i,++p)
		    pos[p] = pos[p] + m[i]
	    }
    }
    for(let i = 0; i < 6; ++i)
	mp(check_segment(i), (i+1)*2)
    g.attributes.position.needsUpdate = true
}

window.rotate_tail = function(segment, angle_hor, angle_vert){
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let rc = tail.rotation_center(segment)
    let c = (segment+1)*2
    for(let a = 0; a < c; ++a)
	for(let b = 0; b < tail.points[a].length; ++b) {
	    let p = tail.points[a][b] * 3
	    function rot(yz, angle) {
		let x1 = pos[p] - rc[0]
		let y1 = pos[p+yz] - rc[yz]
		let g = Math.sqrt(x1*x1 + y1*y1)
		let a0 = Math.asin(y1 / g)
		if(x1 < 0) a0 = Math.PI - a0
		let a1 = a0 + angle * Math.PI / 180
		pos[p] = rc[0] + g * Math.cos(a1)
		pos[p+yz] = rc[yz] + g * Math.sin(a1)
	    }
	    rot(2, angle_hor)
	    rot(1, angle_vert)
	}
    g.attributes.position.needsUpdate = true
}

  </script>
</body>
</html>
