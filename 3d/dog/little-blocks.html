<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Рисуем собакена</title>
  <script src="https://threejs.org/build/three.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="three-animate.js"></script>
  <script src="dog-paw.js"></script>
</head>
<body>
  <script type="module">
    import { GLTFLoader } from 'https://threejs.org/examples/jsm/loaders/GLTFLoader.js'

let sitting = false
let lying = false
let paw_up = false
let left_paw = false
let turned = false
let movingpaws_animate
let bone_mesh_origin
let taken_bone, thrown_bone, thrown_bone_start_x, thrown_bone_max_x

let scene = new THREE.Scene()
let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 )

let renderer = new THREE.WebGLRenderer()
renderer.setSize( window.innerWidth * 0.9, window.innerHeight * 0.9 )
renderer.setClearColor( 0xffffff, 1 )
document.body.appendChild( renderer.domElement )
renderer.shadowMap.enabled = true
scene.add(new THREE.AmbientLight(0xffffff, 0.6))
let point_light = new THREE.PointLight(0xffffff, 0.5)
// let point_light = new THREE.DirectionalLight(0xffffff, 5)
point_light.position.set( -500, 700, 300 )
point_light.castShadow = true
point_light.shadow.camera.far = 5000
scene.add(point_light)

function euler_xyz(quat) {
    let euler = (new THREE.Euler()).setFromQuaternion(quat, 'XYZ')
    function a(v) { return Math.round(THREE.MathUtils.radToDeg(v)) }
    return [a(euler.x), a(euler.y), a(euler.z)]
}

function lip(g, ind, base_i, prev_i) { // linked index points
    let next = []
    let base = base_i.map(function(p) { return ind[p] })
    let prev = prev_i.map(function(p) { return ind[p] })
    for(let t = 0; t < g.index.count; t = t + 3) {
	if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
	    for(let i = t; i < t + 3; ++i) {
		let p = ind[i]
		if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
		    next.push(p)
	    }
    }
    let next_i = []
    ind.forEach(function(p,i) { if(next.includes(p)) next_i.push(i) })
    next_i.sort((a,b)=>a-b)
    return next_i
}

function lp(g, base, prev) { // linked points
    let ind = g.index.array
    let next = []
    for(let t = 0; t < g.index.count; t = t + 3) {
	if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
	    for(let i = t; i < t + 3; ++i) {
		let p = ind[i]
		if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
		    next.push(p)
	    }
    }
    next.sort((a,b)=>a-b)
    return next
}

function lp_eq_y(g, base, prev) {
    let next = []
    let y = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, base[0]).y
    lp(g, base, prev).forEach(function(p) {
	if((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p).y == y) next.push(p)
    })
    return next
}

function lp_lt_y(g, base, prev) {
    let next = []
    let y = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, base[0]).y
    lp(g, base, prev).forEach(function(p) {
	if((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p).y < y) next.push(p)
    })
    return next
}

function p2t(g, points) { // Points to Triangles
    let ind = g.index.array
    let triangles = []
    for(let t = 0; t < g.index.count; t = t + 3) {
	if(points.includes(ind[t]) &&
	   points.includes(ind[t+1]) &&
	   points.includes(ind[t+2])) {
	    if(triangles.length &&
	       t == triangles[triangles.length - 2] +
	       triangles[triangles.length - 1])
		triangles[triangles.length - 1] += 3
	    else triangles.push(t, 3)
	}
    }
    return triangles
}

function range(start, length) {
    return Array.from({length:length},(v,k)=>start+k)
}
function ri(ind, start, length) { // Range Index
    return range(start, length).map(i=>ind[i])
}
function rp(exclude, ind) { // Range points
    let res1 = []
    for(let i = 1; i < arguments.length; ) {
	let start = arguments[++i]
	let length = arguments[++i]
	res1.push(ri(ind, start, length))
    }
    res1 = res1.flat()
    res1.sort((a,b)=>a-b)
    let res = []
    res1.forEach(function(v) {
	if(!res.length || res[res.length-1] != v)
	    if(!exclude.includes(v))
		res.push(v)
    })
    return res
}

function map_points_to_vectors(g,p) {
    return p.map(function(p) {
	return (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
    })
}

function calc_centre(list) {
    let pos = window.dog.attributes.position.array
    if(list.length == 0) return
    else if(list.length == 1) {
	let a = list[0] * 3
	return Array.from(pos.slice(a, a + 3))
    }
    else {
	let s = [0,0,0]
	list.forEach(function(item) {
	    let a = item * 3
	    for(let i = 0; i < 3; ++i,++a) s[i] = s[i] + pos[a]
	})
	return s.map((v) => v / list.length)
    }
}

window.tail = {
    points: [
	[354],
    ],
    bases: [], // 0..6
    delta: 0.2,
    init: function() {
	let g = window.dog
	let ind = g.index.array
	let pos = g.attributes.position.array
	function lp(base, prev) { // linked points
	    let next = []
	    for(let t = 0; t < g.index.count; t = t + 3) {
		if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
		    for(let i = t; i < t + 3; ++i) {
			let p = ind[i]
			if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
			    next.push(p)
		    }
	    }
	    next.sort((a,b)=>a-b)
	    return next
	}
	tail.points.push(lp(tail.points[tail.points.length-1], []))
	for(let i = 2; i < 14; ++i)
	    tail.points.push(lp(tail.points[tail.points.length-1],
				tail.points[tail.points.length-2]))
	// считаем bases
	let prev_rc
	let centres = tail.centres()
	for(let s = 0; s < 6; ++s) {
	    let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centres[s*2]), (new THREE.Vector3()).fromArray(centres[s*2+1]))
	    let angle = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize()).conjugate()
	    let rc = (new THREE.Vector3()).fromArray(tail.rotation_centre(centres, s))
	    let bases_points = []
	    for(let n = 1; n >= 0; --n) {
		tail.points[s*2+n].forEach(function(p) {
		    let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), rc).applyQuaternion(angle)
		    bases_points.push(v.x, v.y, v.z)
		})
	    }
	    if(s) {
		let v = (new THREE.Vector3()).subVectors(prev_rc, rc).applyQuaternion(angle)
		bases_points.push(v.x, v.y, v.z)
	    }
	    tail.bases.push(bases_points)
	    prev_rc = rc
	}
	// bases[6]
	{
	    let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centres[12]), (new THREE.Vector3()).fromArray(centres[13]))
	    let angle = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize()).conjugate()
	    let rc = (new THREE.Vector3()).fromArray(centres[13])
	    let bases_points = []
	    tail.points[12].forEach(function(p) {
		let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), rc).applyQuaternion(angle)
		bases_points.push(v.x, v.y, v.z)
	    })
	    {   let v = (new THREE.Vector3()).subVectors(prev_rc, rc).applyQuaternion(angle)
		bases_points.push(v.x, v.y, v.z)
	    }
	    tail.bases.push(bases_points)
	}
	tail.current_angles = [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30]
    },
    calc_centre: function(list) {
	let pos = window.dog.attributes.position.array
	if(list.length == 0) return
	else if(list.length == 1) {
	    let a = list[0] * 3
	    return Array.from(pos.slice(a, a + 3))
	}
	else {
	    let s = [0,0,0]
	    list.forEach(function(item) {
		let a = item * 3
		for(let i = 0; i < 3; ++i,++a) s[i] = s[i] + pos[a]
	    })
	    return s.map((v) => v / list.length)
	}
    },
    centres: function() {
	return tail.points.map(tail.calc_centre)
    },
    rotation_centre: function(centres, n) {
	function leg(a,b,c,d) {
	    return Math.pow(centres[a][b] - centres[c][d], 2)
	}
	let s0 = n * 2, s1 = s0+1
	let len0 = Math.sqrt(leg(s0, 0, s1, 0) +
			     leg(s0, 1, s1, 1) +
			     leg(s0, 2, s1, 2))
	// rc === Rotation centre
	let rc0 = []
	for(let i = 0; i < 3; ++i)
	    rc0[i] = centres[s1][i] +
	    (centres[s1][i] - centres[s0][i]) * tail.delta / len0
	return rc0
    },
}

let loader = new GLTFLoader()
loader.load('little-blocks-conv.glb', function(gltf) {
    // console.log(gltf)
    let mesh = gltf.scene.children[0]
    // mesh.scale.set(10, 10, 10)
    let material = new THREE.MeshStandardMaterial({ color: 0x97612f })
    let material_red = new THREE.MeshStandardMaterial({ color: 0xff0000 })
    let material_black = new THREE.MeshStandardMaterial({ color: 0x000000 })
    let material_almostblack = new THREE.MeshStandardMaterial({ color: 0x190707 })
    mesh.material = [material, material_red, material_black, material_almostblack]
    mesh.castShadow = true
    mesh.geometry.addGroup(0, 48, 0)
    mesh.geometry.addGroup(48, 12, 3) // левый глаз
    mesh.geometry.addGroup(60, 30, 0)
    mesh.geometry.addGroup(90, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(93, 3, 0)
    mesh.geometry.addGroup(96, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(99, 6, 0)
    mesh.geometry.addGroup(105, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(108, 6, 0)
    mesh.geometry.addGroup(114, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(117, 66, 0)
    mesh.geometry.addGroup(183, 18, 3) // нос
    mesh.geometry.addGroup(201, 6, 0) // нижняя челюсть
    mesh.geometry.addGroup(207, 27, 0)
    mesh.geometry.addGroup(234, 9, 3) // нос
    mesh.geometry.addGroup(243, 3, 0) // нижняя челюсть
    mesh.geometry.addGroup(246, 12, 3) // нос
    mesh.geometry.addGroup(258, 3, 0)
    mesh.geometry.addGroup(261, 6, 3) // нос
    mesh.geometry.addGroup(267, 2328, 0)
    mesh.geometry.addGroup(2595, 3, 3) // нос
    mesh.geometry.addGroup(2598, 6, 0)
    mesh.geometry.addGroup(2604, 3, 3) // нос
    mesh.geometry.addGroup(2607, 3, 0)
    mesh.geometry.addGroup(2610, 6, 3) // нос
    mesh.geometry.addGroup(2616, 9, 0)
    mesh.geometry.addGroup(2625, 3, 3) // нос
    mesh.geometry.addGroup(2628, 9, 0)
    mesh.geometry.addGroup(2637, 6, 3) // нос
    mesh.geometry.addGroup(2643, 42, 0)
    mesh.geometry.addGroup(2685, 3, 3) // нос
    mesh.geometry.addGroup(2688, 3, 0)
    mesh.geometry.addGroup(2691, 3, 3) // нос
    mesh.geometry.addGroup(2694, 3, 0)
    mesh.geometry.addGroup(2697, 6, 3) // нос
    mesh.geometry.addGroup(2703, 45, 0)
    scene.add(mesh)
    window.dog = mesh.geometry
    window.dog_mesh = mesh
    tail.init()
    window.tail = tail
    window.frpaw = new Paw(mesh.geometry, [219, 222, 229]) // front right paw
    window.flpaw = new Paw(mesh.geometry, [186, 188, 196])
    window.brpaw = new Paw(mesh.geometry, [388, 389, 432]) // back right paw
    window.blpaw = new Paw(mesh.geometry, [379, 380, 395])
    window.rare = new Rare()
    window.body = new Body()
    window.head_neck = new HeadNeck()
    window.head = new Head()
    window.jaw = new LowerJaw()
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    if(0) { // общее число точек
	console.log(ind)
	console.log(pos)
    }
    // // нос
    // console.log(lip(g, ind, [189,190,191,195,196,197,198,199,200,201,202,203], []))
    if(0) { // ищем заново нос после добавления рта
	let n = 0, nose_points = []
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(
		g.attributes.position, p)
            if(v.x > 5.9 && v.y > 3.18) { // если поставим v.y < , найдём часть нижней челюсти
		console.log (n++, p, v)
		nose_points.push(p)
	    }
	}
	console.log('nose_points', nose_points)
	console.log('nose_triangles', p2t(g, nose_points))
    }
    if(0) { // ищем нижнюю челюсть
        let base = [8, 14, 18, 52, 53, 54, 59, 60]
        let next = lp(g, base, [])
        console.log(next, map_points_to_vectors(g, next))
        // next = [7, 9, 15, 17, 446, 450, 452, 453, 454]
        // 451 - лишняя
    }
    function sort_points_z(a,b) {
        let av = (new THREE.Vector3()).fromBufferAttribute(
	    g.attributes.position, a)
        let bv = (new THREE.Vector3()).fromBufferAttribute(
	    g.attributes.position, b)
	return av.z - bv.z
    }
    if(0) { // ищем точки челюстей для корректировки - нижняя
	let n = 0
	let a = []
	jaw.points.forEach(function(p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(
		g.attributes.position, p)
	    if(v.y >= 3.15 && v.x >= 6) {
		a.push(p)
		console.log(++n, p, v)
	    }
	})
	console.log(a.sort((a,b)=>a-b)) // [17, 52, 53, 54, 59, 60, 446]
	console.log(a.sort(sort_points_z)) // [17, 54, 52, 53, 59, 60, 446]
    }
    if(0) { // ищем точки челюстей для корректировки - верхняя
	let n = 0
	let a = []
	head_neck.points.forEach(function(p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(
		g.attributes.position, p)
	    if(!jaw.points.includes(p) && v.y <= 3.25 && v.x >= 6) {
		a.push(p)
		console.log(++n, p, v)
	    }
	})
	console.log(a.sort((a,b)=>a-b)) // [5, 64, 65, 66, 447, 448, 449]
	console.log(a.sort(sort_points_z)) // [5, 65, 64, 449, 66, 448, 447]
    }
    if(0) { // ищем заново глаза после добавления рта
	let n = 0, eye_points = []
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(
		g.attributes.position, p)
            if(v.x > 4.71 && v.x <= 4.72) {
		console.log (n++, p, v)
		eye_points.push(p)
	    }
	}
	console.log('eye_points', eye_points)
	console.log(lp(g, eye_points, []))
	eye_points = eye_points.concat(lp(g, eye_points, []))
	console.log('eye_triangles', p2t(g, eye_points))
    }
    // правая передняя нога
    // console.log(ri(ind, 1350, 9))
    if(0) {
        console.log(rp([window.tail.points[13],
		    window.brpaw.get_points()[6],
		    window.blpaw.get_points()[6],
		   ].flat(), ind,
		   351, 33, 606, 27, // цилиндр тела
		   1248, 90, // попа
		   1350, 9, // попа
		   1362, 3, // попа
		   1374, 51, // попа
		   1449, 51, // попа
		  ))
    }
    if(0) {
        let start = [window.tail.points[13],
		    window.brpaw.get_points()[6],
		    window.blpaw.get_points()[6],
		   ].flat()
        let prev = [window.tail.points[12],
		    window.brpaw.get_points()[5],
		    window.blpaw.get_points()[5],
		    window.body.points
		   ].flat()
        let first = lp(g, start, prev)
        console.log(first)
        let second = lp(g, first, [start, prev].flat())
        console.log(second)
        let third = lp(g, second, [first, start, prev].flat())
        console.log(third)
    }
    // console.log((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, 342))
    if(0) rare.points.forEach(function(p) {
	let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
	if(v.x <= -5.29 && v.x >= -5.31 && v.y >= 0.69) console.log('p', p, 'v', v)
    })
    // console.log(tail.points)
    if(0) tail.points[1].forEach(function(p) {
	let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
	console.log(p, v.x)
    })

    if(0) {
    // ind[567] == 106
    console.log(ind[567],
		(new THREE.Vector3()).fromBufferAttribute(g.attributes.position, ind[567]),
		lp(g, [106, 107, 116], []),
		lp_eq_y(g, [106, 107, 109, 110, 112, 113, 115, 116], []),
		lp_lt_y(g, [106, 107, 109, 110, 112, 113, 115, 116], []),
		lp(g, [108, 111, 114, 117, 201, 202, 203, 204], [106, 107, 109, 110, 112, 113, 115, 116]))
    let paw = [[106, 107, 109, 110, 112, 113, 115, 116],
	       [108, 111, 114, 117, 201, 202, 203, 204]
	      ]
    for(;;) {
	let next = lp(g, paw[paw.length - 1], paw[paw.length - 2])
	if(!next.length) break
	paw.push(next)
	console.log(next)
    }
    console.log((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, 209))
    console.log(g.attributes.position.count)
    for(let p = 0; p < g.attributes.position.count; ++p) {
        let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
        if(v.y > -6.86 && v.y < -6.84) console.log (p, v)
    }
    //console.log(g)
    }
    if(0) { // ищем базовые точки для ступней // 220, 223, 230 - левая передняя // 187, 189, 197 - правая передняя
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if(v.y == -7 && (v.z == 1 || v.z == -1 || (v.z > 0.759 && v.z < 0.761) || (v.z < -0.759 && v.z > -0.761))) console.log (p, v)
	}
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if(v.y > -6.86 && v.y < -6.84 && (v.z == 1 || v.z == -1 || (v.z > 0.759 && v.z < 0.761) || (v.z < -0.759 && v.z > -0.761))) console.log ('+', p, v)
	}
    }
    if(0) { // ищем туловище // 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 130, 131, 132, 133
	let n = 0
        if(0) {
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if((v.x > 0.62 && v.x < 0.66) || (v.x > -3.1 && v.x < -2.9)) console.log (++n, p, v)
	}
	}
	let front = []
	n = 0
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if(v.x > 0.62 && v.x < 0.66) { console.log (++n, p, v); front.push(p) }
	}
	let back = []
	n = 0
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if(v.x > -3.1 && v.x < -2.9) { console.log (++n, p, v); back.push(p) }
	}
	console.log('front',front,'back',back)
    }
    if(0) { // ищем шею и голову
	let body_front_circle = [80, 81, 83, 85, 86, 88, 89, 91]
	let body_back_circle = [82, 84, 87, 90, 129, 130, 131, 132]
	let l1 = lp(g, body_front_circle,
		    body_back_circle.concat(frpaw.get_points()[6]).concat(flpaw.get_points()[6]))
	console.log(l1)
	console.log(map_points_to_vectors(g, l1))
	// l1 === [70, 74, 76, 77, 78, 105, 108, 109, 110, 128]
	// 70, 74, 76, 77, 78 - часть нижнего ободка шеи
	// 105, 108, 109 - низ груди между передних ног
	// 110, 128 - боковые точки над передними ногами
	let l2 = lp(g, l1, body_front_circle.concat(frpaw.get_points()[6]).concat(flpaw.get_points()[6]))
	console.log(l2)
	console.log(map_points_to_vectors(g, l2))
	// l2 === [61, 62, 67, 71, 72, 73, 75, 104, 106, 107]
	// 61, 67 - часть нижнего ободка шеи
	// 62, 71, 72, 73, 75 - часть верхнего ободка шеи
	// 104, 106, 107 - центр груди
	let l3 = lp(g, l2, l1)
	console.log(l3)
	console.log(map_points_to_vectors(g, l3))
	// l3 === [28, 41, 43, 44, 45, 55, 56, 63, 68, 69, 79]
	// 68 - часть нижнего ободка шеи
	// 63, 69, 79 - часть верхнего ободка шеи
	let lower_neck_circle = [70, 74, 76, 77, 78, 61, 67, 68]
	let upper_neck_circle = [62, 71, 72, 73, 75, 63, 69, 79]
	let head = []
	let base = upper_neck_circle, prev = lower_neck_circle
	console.log('head')
	return
	for(;;) {
	    let next = lp(g, base, prev)
	    if(!next.length) break;
	    head = head.concat(next)
	    prev = base
	    base = next
	    console.log(next)
	    console.log(map_points_to_vectors(g, next))
	}
	head.sort((a,b)=>a-b)
	console.log(head)
	// head === [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 65, 66, 67, 116, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459]
    }
    // ищем хвост - хвост искать в converter
    if(0) { // ищем сдвоенную точку в нижней челюсти // не 448
        let n = 0
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if((v.x > 5.8 && v.x < 6.1 && v.y > 3.1 && v.y < 3.3 && v.z > 0.25 && v.z < 0.4)) console.log (++n, p, v)
	}
    }
})

function Rare() {
    this.points = [242, 243, 244, 246, 247, 248, 249, 250, 252, 267, 270, 271, 272, 273, 245, 266]
    let centre = new THREE.Vector3(-4, -0.3, 0) // -5.5, -0.4, 0
    let bases
    this.current_angle = 0
    let g = window.dog
    this.points = this.points.concat(tail.points.flat()).concat(brpaw.get_points().flat()).concat(blpaw.get_points().flat())
    this.calc_bases = function() {
	bases = []
	this.points.forEach(function(p) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), centre)
            bases.push(v.x, v.y, v.z)
	})
    }
    this.calc_bases()
    this.rotate = function(angle_z) {
        this.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
        g.attributes.position.needsUpdate = true
    }
    this.get_centre = function() { return centre }
}

function Body() {
    // были удалены точки 81 и 82
    this.points = [80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 129, 130, 131, 132] // обратить внимание, что передний и задний ободки здесь перемешаны - смотри body_front_circle и body_back_circle выше
    let centre = new THREE.Vector3(2, -1.2, 0)
    this.get_centre = function(){return centre}
    let centre_rare = new THREE.Vector3(-3, -0.34, 0)
    let bases = []
    let bases_rare = []
    this.current_angle = 0
    let g = window.dog
    this.points = this.points.concat(tail.points.flat()).concat(brpaw.get_points().flat()).concat(blpaw.get_points().flat()).concat(rare.points)
    this.points.forEach(function(p) {
        let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), centre)
        bases.push(v.x, v.y, v.z)
        let vr = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), centre_rare)
        bases_rare.push(vr.x, vr.y, vr.z)
    })
    function paw_bases(paw) {
        let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(paw.get_base_rotation_centre()), centre)
        return [v.x, v.y, v.z]
    }
    this.calc_paw_bases = function() {
	this.brpaw_bases = paw_bases(brpaw)
	this.blpaw_bases = paw_bases(blpaw)
    }
    this.calc_paw_bases()
    let rare_centre_base = (new THREE.Vector3()).subVectors(rare.get_centre(), centre)
    this.rotate = function(angle_z) {
        this.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
	function paw_centre(paw, bases) {
	    let v = (new THREE.Vector3()).fromArray(bases).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre, v)
	    let rc = paw.get_base_rotation_centre()
	    rc[0] = d.x
	    rc[1] = d.y
	    rc[2] = d.z
	}
	paw_centre(brpaw, this.brpaw_bases)
	paw_centre(blpaw, this.blpaw_bases)
	rare.get_centre().copy((new THREE.Vector3()).addVectors(centre, (new THREE.Vector3()).copy(rare_centre_base).applyQuaternion(angle)))
	rare.calc_bases()
        g.attributes.position.needsUpdate = true
    }
    this.rotate_around_rare = function(angle_z) {
        this.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases_rare, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre_rare, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
        g.attributes.position.needsUpdate = true
    }
}

function HeadNeck() {
    let chest = [104, 106, 107]
    let lower_neck_circle = [70, 74, 76, 77, 78, 61, 67, 68]
    let upper_neck_circle = [62, 71, 72, 73, 75, 63, 69, 79]
    // console.log('lower', calc_centre(lower_neck_circle), 'upper', calc_centre(upper_neck_circle))
    let head = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 64, 65, 66, 115, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458]
    this.points = head.concat(upper_neck_circle).concat(lower_neck_circle).concat(chest)
    let centre = new THREE.Vector3(1.9, 0, 0)
    let bases
    this.current_angle = 0
    let g = window.dog
    this.calc_bases = function() {
	bases = []
	this.points.forEach(function(p) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), centre)
            bases.push(v.x, v.y, v.z)
	})
    }
    this.calc_bases()
    this.rotate = function(angle_z) {
        this.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
        g.attributes.position.needsUpdate = true
    }
    this.get_centre = function() { return centre }
}

function Head() {
    let upper_neck_circle = [62, 71, 72, 73, 75, 63, 69, 79]
    let head = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 64, 65, 66, 115, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458]
    this.points = head.concat(upper_neck_circle)
    let upper_centre = new THREE.Vector3(3.3, 3.05, 0)
    let lower_centre = new THREE.Vector3(2.538, 1.2, 0)
    let centre = upper_centre
    let axis = (new THREE.Vector3()).subVectors(upper_centre, lower_centre).normalize()
    let bases
    this.current_angle = 0
    let g = window.dog
    let z_axis_base = new THREE.Vector3(0,0,1)
    this.z_axis = z_axis_base
    this.calc_bases = function() {
	bases = []
	this.points.forEach(function(p) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), centre)
            bases.push(v.x, v.y, v.z)
	})
    }
    this.calc_bases()
    this.rotate = function(angle_y) {
	// console.log(THREE.MathUtils.radToDeg(angle_y))
        this.current_angle = angle_y
        let angle = (new THREE.Quaternion()).setFromAxisAngle(axis, angle_y)
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
	this.z_axis = z_axis_base.clone()
	this.z_axis.applyQuaternion(angle)
	// console.log('a:', angle_y, 'b:', z_axis_base, 'axis:', this.z_axis)
        g.attributes.position.needsUpdate = true
    }
}

function LowerJaw() {
    this.points = [8, 14, 18, 52, 53, 54, 59, 60, 7, 9, 15, 17, 446, 450, 452, 453, 454]
    let g = window.dog
    let centre
    let bases
    this.current_angle = 0
    this.calc_bases = function() {
        centre = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, 451)
	bases = []
	this.points.forEach(function(p) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), centre)
            bases.push(v.x, v.y, v.z)
	})
    }
    this.calc_bases()
    this.rotate_angle = function(angle) {
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(centre, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
        g.attributes.position.needsUpdate = true
    }
    this.rotate = function(angle_z) {
        this.current_angle = angle_z
        this.rotate_angle((new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ')))
    }
    this.rotate_axis = function(axis, angle_z) {
        this.current_angle = angle_z
        this.rotate_angle((new THREE.Quaternion()).setFromAxisAngle(axis, angle_z))
    }
    this.get_centre = function() { return centre }
}

let loadManager = new THREE.LoadingManager()
let texture_loader = new THREE.TextureLoader(loadManager)

let tiles = []
let tile_x_size = 3.42

loader.load('tile.glb', function(gltf) {
    let mesh = gltf.scene.children[1]
    let material = new THREE.MeshStandardMaterial({/* color: 0x404030,*/ map: texture_loader.load('texture.jpg')})
    mesh.material = material
    //let texture = loader.load('../elerozhka/3d/dog/texture.jpg')
    mesh.receiveShadow = true
    // mesh.position.set(0,-7,0)
    // scene.add(mesh)
    for(let x = -20; x <= 20; ++x)
	for(let y = -4; y <= 4; ++y) {
	    let mesh1 = mesh.clone()
	    mesh1.position.set(x * tile_x_size, -7, y * 2 * 1.666)
	    scene.add(mesh1)
	    tiles.push({x: mesh1.position.x, y: mesh1.position.y, z: mesh1.position.z, m: mesh1})
	    let mesh2 = mesh.clone()
	    mesh2.position.set(x * tile_x_size + 1.71, -7, (y * 2 + 1) * 1.666)
	    scene.add(mesh2)
	    tiles.push({x: mesh2.position.x, y: mesh2.position.y, z: mesh2.position.z, m: mesh2})
	}
})

let bone_pivot_x = 1.9 + 1.224, bone_pivot_y = -1.5
loader.load('bone.glb', function(gltf) {
    let mesh = gltf.scene.children[2]
    let material = new THREE.MeshStandardMaterial({ color: 0xCD853F })
    mesh.material = material
    mesh.receiveShadow = true
    mesh.castShadow = true
    // mesh.position.set(0, 0, 0)
    mesh.rotation.set(0,Math.PI/2,0)
    bone_mesh_origin = mesh
})

camera.position.set(-4, 0, 14)
let controls = new THREE.OrbitControls( camera, renderer.domElement )

function animate() {
    requestAnimationFrame( animate )
    renderer.render( scene, camera )
}
animate()

let tile_delta_x = 0
function dog_updown(y) {
    dog_mesh.position.y = y
    if(taken_bone) bone_pivot.position.y = y
}

function move_tiles(x) {
    tiles.forEach(function(tile) {
        tile.m.position.x = tile.x + tile_delta_x - x
    })
    if(thrown_bone) {
	let new_x = thrown_bone_start_x - x
	if(thrown_bone.position.x >= new_x) thrown_bone.position.x = new_x
	else {
	    thrown_bone.position.x = new_x - thrown_bone_max_x
	    thrown_bone_start_x -= thrown_bone_max_x
	}
	if(thrown_bone.position.x <= -20 * tile_x_size) scene.remove(window.bone_pivot)
    }
}

window.go = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let period = 1000
    let one = function(paw) {
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,0,0,0,0],
          [0,0,10,0,0,-35,0,0,20],
          100, 200)
    a.rotate_array_callback(paw.rotate,
          [0,0,10,0,0,-35,0,0,20],
          [0,0,20,0,0,-55,0,0,20],
          200, 300)
    a.rotate_array_callback(paw.rotate,
          [0,0,20,0,0,-55,0,0,20],
          [0,0,25,0,0,0,0,0,-25],
          300, 500, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,25,0,0,0,0,0,-25],
          [0,0,0,0,0,0,0,0,0],
          500, 750, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,0,0,0,0],
          [0,0,-25,0,0,0,0,0,15],
          750, 1000, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,-25,0,0,0,0,0,15],
          [0,0,0,0,0,-55,0,0,20],
          1000, 1100, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,-55,0,0,20],
          [0,0,20,0,0,-55,0,0,20],
	  1100, 1300, period)
    }
    let two = function(paw) {
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,0,0,0,0],
          [0,0,-25,0,0,0,0,0,15],
          300, 550, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,-25,0,0,0,0,0,15],
          [0,0,0,0,0,-55,0,0,20],
          550, 650, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,-55,0,0,20],
          [0,0,20,0,0,-55,0,0,20],
	  650, 850, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,20,0,0,-55,0,0,20],
          [0,0,25,0,0,0,0,0,-25],
          850, 1050, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,25,0,0,0,0,0,-25],
          [0,0,0,0,0,0,0,0,0],
          1050, 1300, period)
    }
    one(frpaw)
    one(blpaw)
    two(flpaw)
    two(brpaw)
    let tile_start = 300
    let tile_period = 417.68
    thrown_bone_max_x = tile_x_size
    a.rotate_array_callback(move_tiles, [0], [tile_x_size], tile_start, tile_start + tile_period, tile_period)
    a.rotate_array_callback(dog_updown, [0], [-0.4], 300, 550, 500)
    a.rotate_array_callback(dog_updown, [-0.4], [0], 550, 800, 500)
    a.rotate_array_callback(tail.rotate, [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
                                         [0,8,0,-9,0,-25,0,-20,0,-45,0,-35,0,-20],
                                         300, 400, 500)
    a.rotate_array_callback(tail.rotate, [0,8,0,-9,0,-25,0,-20,0,-45,0,-35,0,-20],
                                         [0,8,0,-9,0,-25,0,-20,0,-45,0,-55,0,-40],
                                         400, 600, 500)
    a.rotate_array_callback(tail.rotate, [0,8,0,-9,0,-25,0,-20,0,-45,0,-55,0,-40],
                                         [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
                                         600, 800, 500)
    a.start()
    return a
}

window.stop = function(a, fincb) {
    a.exit_now = true
    tile_delta_x = tiles[0].m.position.x - tiles[0].x
    while(tile_delta_x < -tile_x_size) tile_delta_x += tile_x_size
    let b = new Animate4;
    [frpaw,flpaw,brpaw,blpaw].forEach(function(paw) {
	b.rotate_array_callback(paw.rotate,
				[...paw.current_angles()],
				[0,0,0,0,0,0,0,0,0],
				0, 200)
    })
    b.rotate_array_callback(dog_updown, [dog_mesh.position.y], [0], 0, 200)
    b.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        0, 200)
    if(fincb) b.finish(fincb)
    b.start()
}

window.correct_tail = function() {
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centres = tail.centres()
    function leg(a,b,c,d) {
	return Math.pow(centres[a][b] - centres[c][d], 2)
    }
    function check_segment(n) {
	let s0 = n * 2, s1 = s0+1, s2 = s0+2, s3 = s0+3
	let len0 = Math.sqrt(leg(s0, 0, s1, 0) +
			     leg(s0, 1, s1, 1) +
			     leg(s0, 2, s1, 2))
	let len1 = Math.sqrt(leg(s2, 0, s3, 0) +
			     leg(s2, 1, s3, 1) +
			     leg(s2, 2, s3, 2))
	// rp === Rotation centre
	let rc0 = []
	for(let i = 0; i < 3; ++i)
	    rc0[i] = centres[s1][i] +
	    (centres[s1][i] - centres[s0][i]) * tail.delta / len0
	let rc0a = []
	for(let i = 0; i < 3; ++i)
	    rc0a[i] = centres[s2][i] -
	    (centres[s3][i] - centres[s2][i]) * tail.delta / len1
	let m = []
	for(let i = 0; i < 3; ++i) m[i] = rc0a[i] - rc0[i]
	return m
    }
    function mp(m, c) { // Move Points
	// console.log(m)
	for(let a = 0; a < c; ++a)
	    for(let b = 0; b < tail.points[a].length; ++b) {
		let p = tail.points[a][b] * 3
		for(let i = 0; i < 3; ++i,++p)
		    pos[p] = pos[p] + m[i]
	    }
    }
    for(let i = 0; i < 6; ++i)
	mp(check_segment(i), (i+1)*2)
    g.attributes.position.needsUpdate = true
}

window.get_angles = function() {
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centres = tail.centres()
    // console.log('centres.length', centres.length)
    let angles = []
    function a(v) { return Math.round(THREE.MathUtils.radToDeg(v)) }
    for(let s = 0; s < 6; ++s) {
	let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centres[s*2]), (new THREE.Vector3()).fromArray(centres[s*2+1]))
	let pre = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centres[(s+1)*2]), (new THREE.Vector3()).fromArray(centres[(s+1)*2+1]))
	// console.log('s', s, 'cur', cur, 'pre', pre)
	let angle = (new THREE.Euler()).setFromQuaternion((new THREE.Quaternion()).setFromUnitVectors(pre.normalize(), cur.normalize()), 'XYZ')
	let angle2 = (new THREE.Euler()).setFromQuaternion((new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize()), 'XYZ')
	angles.push([a(angle.x), a(angle.y), a(angle.z), a(angle2.x), a(angle2.y), a(angle2.z)])
    }
    /*
    console.log(tail.points[13])
    tail.points[13].forEach(function(p){
	let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
	console.log('p', p, 'v', v, 'pos', pos[p*3], pos[p*3+1], pos[p*3+2])
    })
    */
    // 3 - 248 - верх | 4 - 251 - максимально положительная z
    let up = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][3]), (new THREE.Vector3()).fromArray(centres[13]))
    let side = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][4]), (new THREE.Vector3()).fromArray(centres[13]))
    let a1 = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(0,-1,0), up.normalize())
    // в начальном состоянии собакена нет поворота вокруг вектора up, поэтому пока не будем учитывать поворот для вектора side. его надо будет учесть, когда научим собакена вилять всей попой.
    let a1e = (new THREE.Euler()).setFromQuaternion(a1, 'XYZ')
    let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centres[12]), (new THREE.Vector3()).fromArray(centres[13]))
    let c1 = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize())
    // c1 = a1 * c2
    let c2 = c1.clone().multiply(a1.conjugate())
    let angle = (new THREE.Euler()).setFromQuaternion(c2, 'XYZ')
    let angle2 = (new THREE.Euler()).setFromQuaternion(c1, 'XYZ')
    angles.push([a(angle.x), a(angle.y), a(angle.z), a(angle2.x), a(angle2.y), a(angle2.z)])
    angles.push([a(a1e.x), a(a1e.y), a(a1e.z)])
    return angles
}

window.rotate_tail_v1 = function(segment, angle_hor, angle_vert){
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centres = tail.centres()
    let rc = tail.rotation_centre(centres, segment)
    let angle_centre = centres[segment * 2]
    // console.log('rc:', rc, 'ac:', angle_centre); return;
    function ang(yz) {
	let x1 = angle_centre[0] - rc[0]
	let y1 = angle_centre[yz] - rc[yz]
	if(x1 == 0 && y1 == 0) return 0
	let g = Math.sqrt(x1*x1 + y1*y1)
	let a0 = Math.asin(y1 / g)
	if(x1 < 0) a0 = Math.PI - a0
	return a0 * 180 / Math.PI
    }
    angle_hor = angle_hor - ang(2)
    angle_vert = angle_vert - ang(1)
    let c = (segment+1)*2
    for(let a = 0; a < c; ++a)
	for(let b = 0; b < tail.points[a].length; ++b) {
	    let p = tail.points[a][b] * 3
	    function rot(yz, angle) {
		let x1 = pos[p] - rc[0]
		let y1 = pos[p+yz] - rc[yz]
		let g = Math.sqrt(x1*x1 + y1*y1)
		let a0 = x1 == 0 && y1 == 0 ? 0 : Math.asin(y1 / g)
		if(x1 < 0) a0 = Math.PI - a0
		let a1 = a0 + angle * Math.PI / 180
		pos[p] = rc[0] + g * Math.cos(a1)
		pos[p+yz] = rc[yz] + g * Math.sin(a1)
	    }
	    rot(2, angle_hor)
	    rot(1, angle_vert)
	}
    g.attributes.position.needsUpdate = true
}

window.rotate_tail_base = function(angle_hor, angle_vert){
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centres = tail.centres()
    let rc = centres[13]
    let angle_centre = centres[12]
    function ang(yz) {
	let x1 = angle_centre[0] - rc[0]
	let y1 = angle_centre[yz] - rc[yz]
	if(x1 == 0 && y1 == 0) return 0
	let g = Math.sqrt(x1*x1 + y1*y1)
	let a0 = Math.asin(y1 / g)
	if(x1 < 0) a0 = Math.PI - a0
	return a0 * 180 / Math.PI
    }
    angle_hor = angle_hor - ang(2)
    angle_vert = angle_vert - ang(1)
    for(let a = 0; a < 13; ++a)
	for(let b = 0; b < tail.points[a].length; ++b) {
	    let p = tail.points[a][b] * 3
	    function rot(yz, angle) {
		let x1 = pos[p] - rc[0]
		let y1 = pos[p+yz] - rc[yz]
		let g = Math.sqrt(x1*x1 + y1*y1)
		let a0 = x1 == 0 && y1 == 0 ? 0 : Math.asin(y1 / g)
		if(x1 < 0) a0 = Math.PI - a0
		let a1 = a0 + angle * Math.PI / 180
		pos[p] = rc[0] + g * Math.cos(a1)
		pos[p+yz] = rc[yz] + g * Math.sin(a1)
	    }
	    rot(2, angle_hor)
	    rot(1, angle_vert)
	}
    g.attributes.position.needsUpdate = true
}

// начальное состояние
// rotate_tail(0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30)
tail.rotate = function() {
    tail.current_angles = [...arguments]
    let g = window.dog
    let pos = g.attributes.position.array
    let angle
    let rc = (new THREE.Vector3()).fromArray(tail.calc_centre(tail.points[13]))
    {
	let up = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][3]), rc)
	// console.log('rc', rc, 'up', up, '13_3', tail.points[13][3], 'v', (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][3]))
	let side = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][4]), rc)
	angle = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(0,-1,0), up.normalize())
	// в начальном состоянии собакена нет поворота вокруг вектора up, поэтому пока не будем учитывать поворот для вектора side. его надо будет учесть, когда научим собакена вилять всей попой.
	// console.log('angle', angle, euler_xyz(angle))
    }
    {
	let euler = new THREE.Euler(0, THREE.MathUtils.degToRad(arguments[0]), THREE.MathUtils.degToRad(arguments[1]), 'XYZ')
	angle = angle.multiply((new THREE.Quaternion()).setFromEuler(euler))
	tail.points[12].forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(tail.bases[6], i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(rc, v)
	    // console.log('i', i, 'p', p, 'old', (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), 'new', d, 'v', v, 'rc', rc, 'angle', angle, euler_xyz(angle))
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	    // let pi = p * 3
	    // pos[pi] = d.x
	    // pos[++pi] = d.y
	    // pos[++pi] = d.z
	})
	{
	    let v = (new THREE.Vector3()).fromArray(tail.bases[6], 8*3).applyQuaternion(angle)
	    rc = (new THREE.Vector3()).addVectors(rc, v)
	}
    }
    // g.attributes.position.needsUpdate = true
    // return
    for(let s = 5; s >= 0; --s) {
	let euler = new THREE.Euler(0, THREE.MathUtils.degToRad(arguments[(6-s)*2]), THREE.MathUtils.degToRad(arguments[(6-s)*2+1]), 'XYZ')
	angle = angle.multiply((new THREE.Quaternion()).setFromEuler(euler))
	for(let n = 0; n < 2; ++n) {
	    tail.points[s*2+n].forEach(function(p,i) {
		let v = (new THREE.Vector3()).fromArray(tail.bases[s],
			((1-n)*8+i)*3).applyQuaternion(angle)
		let d = (new THREE.Vector3()).addVectors(rc, v)
		// if(!s) console.log('n', n, 'i', i, 'p', p, 'old', (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), 'new', d, 'v', v, 'rc', rc, 'angle', angle, euler_xyz(angle))
		g.attributes.position.setXYZ(p, d.x, d.y, d.z)
		// let pi = p * 3
		// pos[pi] = d.x
		// pos[++pi] = d.y
		// pos[++pi] = d.z
	    })
	}
	if(s) {
	    let v = (new THREE.Vector3()).fromArray(tail.bases[s], 16*3).applyQuaternion(angle)
	    rc = (new THREE.Vector3()).addVectors(rc, v)
	}
    }
    g.attributes.position.needsUpdate = true
}

tail.wag_body = function(a, t, p) {
    let base    = [  0,8, 0, -9,  0,-25,  0,-20, 0,-45, 0,-45, 0,-30]
    let quarter = [2.5,8, 5, -9,2.5,-25,7.5,-20, 5,-45,10,-40,10,-27]
    // [2.5,6, 5,-9.25,2.5,-21.25,7.5,-20, 5,-38.75,10,-38.75,10,-25],
    let half    = [  5,8,10, -9,  5,-25, 15,-20,10,-45,20,-30,20,-20]
    let full    = [ 10,0,20,-10, 10,-10, 30,-20,20,-20,40,-20,40,-10]
    function neg(a) {
	a = [...a]
	for(let i = 0; i < a.length; i += 2) a[i] = -a[i]
	return a
    }
    a.rotate_array_callback(tail.rotate, base, quarter, t, t+50, p)
    a.rotate_array_callback(tail.rotate, quarter, half, t+50, t+100, p)
    a.rotate_array_callback(tail.rotate, half, full, t+100, t+200, p)
    a.rotate_array_callback(tail.rotate, full, half, t+200, t+300, p)
    a.rotate_array_callback(tail.rotate, half, quarter, t+300, t+350, p)
    a.rotate_array_callback(tail.rotate, quarter, base, t+350, t+400, p)
    quarter = neg(quarter)
    half = neg(half)
    full = neg(full)
    a.rotate_array_callback(tail.rotate, base, quarter, t+400, t+450, p)
    a.rotate_array_callback(tail.rotate, quarter, half, t+450, t+500, p)
    a.rotate_array_callback(tail.rotate, half, full, t+500, t+600, p)
    a.rotate_array_callback(tail.rotate, full, half, t+600, t+700, p)
    a.rotate_array_callback(tail.rotate, half, quarter, t+700, t+750, p)
    a.rotate_array_callback(tail.rotate, quarter, base, t+750, t+800, p)
}

tail.wag = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    if(sitting) {
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0], [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], 100, 400)
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], [0,-40,0,0,-10,0,-20,0,-30,0,-40,0,-50,0], 400, 800, 800)
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,-10,0,-20,0,-30,0,-40,0,-50,0], [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], 800, 1200, 800)
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0], 1200, 1500)
    }
    else if(turned) {
        a.rotate_array_callback(tail.rotate, [0,50,0,0,0,0,0,0,-30,0,-40,0,-50,0], [0,50,0,0,10,0,20,0,30,0,40,0,50,0], 100, 400)
        a.rotate_array_callback(tail.rotate, [0,50,0,0,10,0,20,0,30,0,40,0,50,0], [0,50,0,0,-10,0,-20,0,-30,0,-40,0,-50,0], 400, 800, 800)
        a.rotate_array_callback(tail.rotate, [0,50,0,0,-10,0,-20,0,-30,0,-40,0,-50,0], [0,50,0,0,10,0,20,0,30,0,40,0,50,0], 800, 1200, 800)
        a.rotate_array_callback(tail.rotate, [0,50,0,0,10,0,20,0,30,0,40,0,50,0], [0,50,0,0,0,0,0,0,-30,0,-40,0,-50,0], 1200, 1500)
    }
    else if(lying) {
        a.rotate_array_callback(tail.rotate, [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0], [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], 100, 400)
        a.rotate_array_callback(tail.rotate, [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], [0,90,0,20,10,-55,20,-10,30,-10,40,0,50,0], 400, 800, 800)
        a.rotate_array_callback(tail.rotate, [0,90,0,20,10,-55,20,-10,30,-10,40,0,50,0], [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], 800, 1200, 800)
        a.rotate_array_callback(tail.rotate, [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0], 1200, 1500)
    }
    else tail.wag_body(a, 100, 800);
    a.start()
    return a
}

tail.to_basic = function(duration) {
    let a = new Animate4
    if(sitting) {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        0, duration)
    }
    else if(turned) {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,50,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        0, duration)
    }
    else if(lying) {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
        0, duration)
    }
    else {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        0, duration)
    }
    a.start()
    return a
}

tail.to_down = function(duration) {
    let a = new Animate4
    a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,90,0,20,0,30,0,30,0,30,0,30,0,10],
        0, duration)
    a.start()
    return a
}

function show_buttons() {
    if(!turned)
        document.getElementById('sit_stand_button').style.display = ''
    if(!sitting && !lying) {
	document.getElementById('go_stop_button').style.display = ''
        document.getElementById('run_button').style.display = ''
        document.getElementById('standup_button').style.display = ''
    }
    document.getElementById('tail_wag_button').style.display = ''
    if(sitting)
	document.getElementById('liedown_par').style.display = ''
    if(lying)
        document.getElementById('turn_button').style.display = ''
    if(!lying)
	document.getElementById('paw_button').style.display = ''
}

function hide_buttons() {
    ['sit_stand_button', 'go_stop_button', 'tail_wag_button',
     'liedown_par', 'paw_button', 'run_button', 'standup_button', 'turn_button'].forEach(function(id) {
	document.getElementById(id).style.display = 'none'
    })
}

window.animate_speed = 1
let go_animate
window.go_stop_button_click = function() {
    document.getElementById('paw_button').style.display = 'none'
    if(go_animate) {
	stop(go_animate)
	document.getElementById('go_stop_button').textContent = 'Пойдём!'
	go_animate = undefined
        document.getElementById('paw_button').style.display = ''
        document.getElementById('run_button').style.display = ''
	if(!tail_wag)
	    document.getElementById('stop_all_par').style.display = 'none'
    }
    else {
        if(tail_wag) {
            tail_wag.exit_now = true
            tail_wag = undefined
	    document.getElementById('tail_wag_button').textContent = ':)'
        }
	go_animate = go(window.animate_speed)
	document.getElementById('go_stop_button').textContent = 'Стой!'
	document.getElementById('stop_all_par').style.display = ''
    }
}

let tail_wag
window.tail_wag_button_click = function() {
    if(tail_wag) {
	tail_wag.exit_now = true
	tail.to_basic(100)
        document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
	if(!go_animate)
	    document.getElementById('stop_all_par').style.display = 'none'
    }
    else {
        tail_wag = tail.wag(window.animate_speed)
        document.getElementById('tail_wag_button').textContent = ':|'
	document.getElementById('stop_all_par').style.display = ''
    }
}

window.stop_all_button_click = function() {
    document.getElementById('stop_all_par').style.display = 'none'
    if(go_animate) {
	stop(go_animate)
	document.getElementById('go_stop_button').textContent = 'Пойдём!'
	go_animate = undefined
        document.getElementById('paw_button').style.display = ''
        document.getElementById('run_button').style.display = ''
    }
    if(tail_wag) {
	tail_wag.exit_now = true
	tail.to_basic(100)
	document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
    }
}

window.test_sit = function(sit) {
    if(sit) {
	body.rotate(55)
	rare.rotate(30)
	brpaw.rotate(30,0,135,0,30,-135,0,0,0)
	blpaw.rotate(-30,0,135,0,-30,-135,0,0,0)
	tail.rotate(0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0)
    }
    else {
	body.rotate(0)
	brpaw.rotate(0,0,0,0,0,0,0,0,0)
	blpaw.rotate(0,0,0,0,0,0,0,0,0)
	tail.rotate(0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30)
    }
}

window.sit = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(brpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,10,0,0,-35,0,0,20],
        100, 200)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,10,0,0,-35,0,0,20],
        [0,0,20,0,0,-55,0,0,20],
        200, 300)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,20,0,0,-55,0,0,20],
        [0,0,25,0,0,0,0,0,-25],
        300, 500)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,10,0,0,-35,0,0,20],
        500, 600)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,10,0,0,-35,0,0,20],
        [0,0,20,0,0,-55,0,0,20],
        600, 700)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,20,0,0,-55,0,0,20],
        [0,0,25,0,0,0,0,0,-25],
        700, 900)
    let first_body_rotate_call = true
    function body_rotate(angle_z) {
	if(first_body_rotate_call) {
	    first_body_rotate_call = false
	    body.calc_paw_bases()
	}
	body.rotate(angle_z)
    }
    a.rotate_array_callback(body_rotate, [0], [55], 900, 1500)
    a.rotate_array_callback(rare.rotate.bind(rare), [0], [30], 900, 1500)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [30,0,80,0,30,-100,0,0,0],
        900, 1150)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [-30,0,80,0,-30,-100,0,0,0],
        900, 1150)
    a.rotate_array_callback(brpaw.rotate,
        [30,0,80,0,30,-100,0,0,0],
        [30,0,135,0,30,-135,0,0,0],
        1150, 1500)
    a.rotate_array_callback(blpaw.rotate,
        [-30,0,80,0,-30,-100,0,0,0],
        [-30,0,135,0,-30,-135,0,0,0],
        1150, 1500)
    a.rotate_array_callback(tail.rotate,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        900, 1500)
    a.finish(function() {
	document.getElementById('sit_stand_button').textContent = 'Стоять!'
	show_buttons()
    })
    a.start()
    return a
}

window.stand = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    if(lying) {
        lying = false
        function dog_mesh_position(y) { dog_mesh.position.y = y }
        a.rotate_array_callback(dog_mesh_position, [-4.8], [-2], 0, 500)
        a.rotate_array_callback(dog_mesh_position, [-2], [0], 500, 1100)
        a.rotate_array_callback(body.rotate.bind(body), [5], [0], 0, 600)
        a.rotate_array_callback(tail.rotate,
            [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
            [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
            0, 600)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,90,0,0,0,0,0,-50],
            [0,0,25,0,0,0,0,0,-25],
            0, 1100)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,90,0,0,0,0,0,-50],
            [0,0,25,0,0,0,0,0,-25],
            0, 1100)
        a.rotate_array_callback(brpaw.rotate,
            [30,-5,135,0,30,-110,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            0, 1000)
        a.rotate_array_callback(blpaw.rotate,
            [-30,-5,135,0,-30,-110,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            0, 1000)
    }
    else {
        sitting = false
        a.rotate_array_callback(body.rotate.bind(body), [55], [0], 0, 600)
        a.rotate_array_callback(rare.rotate.bind(rare), [30], [0], 0, 600)
        let first_rare_rotate_call = true
        function rare_rotate(angle_z) {
	    if(first_rare_rotate_call) {
	        first_rare_rotate_call = false
                rare.calc_tail_bases()
            }
	    rare.rotate(angle_z)
        }
        a.rotate_array_callback(tail.rotate,
            [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
            [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
            0, 600)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,10,0,0,-35,0,0,20],
            600, 700)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,10,0,0,-35,0,0,20],
            [0,0,20,0,0,-55,0,0,20],
            700, 800)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,20,0,0,-55,0,0,20],
            [0,0,25,0,0,0,0,0,-25],
            800, 1000)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,10,0,0,-35,0,0,20],
            1000, 1100)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,10,0,0,-35,0,0,20],
            [0,0,20,0,0,-55,0,0,20],
            1100, 1200)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,20,0,0,-55,0,0,20],
            [0,0,25,0,0,0,0,0,-25],
            1100, 1400)
        a.rotate_array_callback(brpaw.rotate,
            [30,0,135,0,30,-135,0,0,0],
            [30,0,80,0,30,-100,0,0,0],
            0, 350)
        a.rotate_array_callback(blpaw.rotate,
            [-30,0,135,0,-30,-135,0,0,0],
            [-30,0,80,0,-30,-100,0,0,0],
            0, 350)
        a.rotate_array_callback(brpaw.rotate,
            [30,0,80,0,30,-100,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            350, 600)
        a.rotate_array_callback(blpaw.rotate,
            [-30,0,80,0,-30,-100,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            350, 600)
    }
    // общее
    a.rotate_array_callback(frpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    thrown_bone_max_x = tile_x_size
    a.rotate_array_callback(move_tiles, [0], [tile_x_size], 1100, 1500)
    a.finish(function() {
	document.getElementById('sit_stand_button').textContent = 'Сидеть'
	show_buttons()
    })
    a.start()
    return a
}

function stop_current(fincb) {
    if(go_animate) {
        stop(go_animate, fincb)
        go_animate = undefined
	document.getElementById('go_stop_button').textContent = 'Пойдём!'
        document.getElementById('stop_all_par').style.display = 'none'
    }
    else if(fincb) fincb()
    if(tail_wag) {
        tail_wag.exit_now = true
	tail.to_basic(100)
	document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
        document.getElementById('stop_all_par').style.display = 'none'
    }
}

window.sit_stand_button_click = function() {
    stop_current()
    hide_buttons();
    if(sitting || lying) {
	sitting = false
	stand(window.animate_speed)
    }
    else {
	sitting = true
	sit(window.animate_speed)
    }
}

window.liedown = function(tm) {
    lying = true
    sitting = false
    let a = new Animate4
    if(tm) a.time_modifier = tm
    function dog_mesh_position(y) { dog_mesh.position.y = y }
    a.rotate_array_callback(dog_mesh_position, [0], [-0.9], 0, 225)
    a.rotate_array_callback(dog_mesh_position, [-0.9], [-4.8], 225, 750)
    //a.rotate_array_callback(dog_mesh_position, [-3], [-4.8], 500, 800)
    a.rotate_array_callback(body.rotate.bind(body), [55], [5], 0, 750)
    a.rotate_array_callback(rare.rotate.bind(rare), [30], [0], 0, 750)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [30,0,135,0,30,-110,0,0,0],
        0, 750)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [-30,0,135,0,-30,-110,0,0,0],
        0, 750)
    a.rotate_array_callback(tail.rotate,
        [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
        0, 750)
    a.rotate_array_callback(brpaw.rotate,
        [30,0,135,0,30,-110,0,0,0],
        [30,-5,135,0,30,-110,0,0,0],
        0, 1200)
    a.rotate_array_callback(blpaw.rotate,
        [-30,0,135,0,-30,-110,0,0,0],
        [-30,5,135,0,-30,-110,0,0,0],
        0, 1200)
    a.rotate_array_callback(frpaw.rotate,
        [30,0,135,0,30,-110,0,0,0],
        [0,0,90,0,0,0,0,0,-50],
        800, 1400)
    a.rotate_array_callback(flpaw.rotate,
        [-30,0,135,0,-30,-110,0,0,0],
        [0,0,90,0,0,0,0,0,-50],
        800, 1400)
    a.start()
    a.finish(function() {
	show_buttons()
    })
    return a
}
window.liedown_button_click = function() {
    hide_buttons()
    liedown(window.animate_speed)
    if(tail_wag) {
        tail_wag.exit_now = true
	document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
        document.getElementById('stop_all_par').style.display = 'none'
    }
}

function btn_show_title(id, title) {
    let btn = document.getElementById(id)
    btn.textContent = title
    btn.style.display = ''
}

window.paw = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(frpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-60,0,0,0],
        0, 500)
    a.finish(function() {
	btn_show_title('paw_button', 'Опусти лапу')
    })
    a.start()
    return a
}
window.paw_down = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(frpaw.rotate,
        [0,0,90,0,0,-60,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        0, 500)
    a.finish(function() {
	show_buttons();
	btn_show_title('paw_button', 'Другую лапу')
    })
    a.start()
    return a
}
window.an_paw = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(flpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-60,0,0,0],
        0, 500)
    a.finish(function() {
	btn_show_title('paw_button', 'Опусти лапу')
    })
    a.start()
    return a
}
window.an_paw_down = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(flpaw.rotate,
        [0,0,90,0,0,-60,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        0, 500)
    a.finish(function() {
	show_buttons();
	btn_show_title('paw_button', 'Лапу')
    })
    a.start()
    return a
}
window.paw_button_click = function() {
    hide_buttons()
    document.getElementById('tail_wag_button').style.display = ''
    if(!paw_up && !left_paw) {
        paw_up = true
        paw(window.animate_speed)
    }
    else if(paw_up && !left_paw) {
	paw_up = false
	left_paw = true
        paw_down(window.animate_speed)
    }
    else if(!paw_up && left_paw) {
        paw_up = true
        an_paw(window.animate_speed)
    }
    else { // if(paw_up && left_paw) {
	paw_up = false
	left_paw = false
        an_paw_down(window.animate_speed)
    }
}

window.run = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let period = 1000
    let front = function(paw) {
        a.rotate_array_callback(paw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,60,0,0,-110,0,0,0],
            0, 200)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,-110,0,0,0],
            [0,0,60,0,0,0,0,0,-30],
            200, 500)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,0,0,0,-30],
            [0,0,-30,0,0,0,0,0,0],
            500, 1000)
        a.rotate_array_callback(paw.rotate,
            [0,0,-30,0,0,0,0,0,0],
            [0,0,60,0,0,-110,0,0,0],
            1000, 1200, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,-110,0,0,0],
            [0,0,60,0,0,0,0,0,-30],
            1200, 1500, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,0,0,0,-30],
            [0,0,-30,0,0,0,0,0,0],
            1500, 2000, period)
    }
    front(frpaw)
    front(flpaw)
    let back = function(paw) {
        a.rotate_array_callback(paw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,-60,0,0,-20,0,0,0],
            0, 500)
        a.rotate_array_callback(paw.rotate,
            [0,0,-60,0,0,-20,0,0,0],
            [0,0,-15,0,0,-80,0,0,0],
            500, 700)
        a.rotate_array_callback(paw.rotate,
            [0,0,-15,0,0,-80,0,0,0],
            [0,0,30,0,0,-20,0,0,0],
            700, 1000)
        a.rotate_array_callback(paw.rotate,
            [0,0,30,0,0,-20,0,0,0],
            [0,0,-60,0,0,-20,0,0,0],
            1000, 1500, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,-60,0,0,-20,0,0,0],
            [0,0,-15,0,0,-80,0,0,0],
            1500, 1700, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,-15,0,0,-80,0,0,0],
            [0,0,30,0,0,-20,0,0,0],
            1700, 2000, period)
    }
    back(brpaw)
    back(blpaw)
    a.rotate_array_callback(tail.rotate,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        [0,20,0,20,0,-20,0,20,0,-20,0,20,0,-20],
        0, 500)
    a.rotate_array_callback(tail.rotate,
        [0,20,0,20,0,-20,0,20,0,-20,0,20,0,-20],
        [0,10,0,17,0,-23,0,17,0,-23,0,17,0,-23],
        500, 1000, period)
    a.rotate_array_callback(tail.rotate,
        [0,10,0,17,0,-23,0,17,0,-23,0,17,0,-23],
        [0,20,0,20,0,-20,0,20,0,-20,0,20,0,-20],
        1000, 1500, period)
    let tile_start = 0
    let tile_period = 417.68
    thrown_bone_max_x = tile_x_size*2
    a.rotate_array_callback(move_tiles, [0], [tile_x_size*2], tile_start, tile_start + tile_period, tile_period)
    a.rotate_array_callback(dog_updown, [0], [1], 0, 500, 1000)
    a.rotate_array_callback(dog_updown, [1], [0], 500, 1000, 1000)
    a.finish(function() {
    })
    a.finish(function() {
	show_buttons();
    })
    a.start()
    return a
}

window.run_button_click = function() {
    if(go_animate) go_animate.exit_now = true
    go_animate = run()
    document.getElementById('go_stop_button').textContent = 'Стой!'
    document.getElementById('stop_all_par').style.display = ''
    document.getElementById('run_button').style.display = 'none'
    document.getElementById('paw_button').style.display = 'none'
}

window.standup = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let delta_x = dog_mesh.geometry.attributes.position.array[389*3+0]
    let delta_y = dog_mesh.geometry.attributes.position.array[389*3+1]
    function back_paw_rotate() {
	brpaw.rotate(...arguments)
	blpaw.rotate(...arguments)
	dog_mesh.position.x = delta_x -
	    dog_mesh.geometry.attributes.position.array[389*3+0]
	dog_mesh.position.y = delta_y -
	    dog_mesh.geometry.attributes.position.array[389*3+1]
    }
    a.rotate_array_callback(body.rotate.bind(body), [0], [60], 0, 500)
    a.rotate_array_callback(back_paw_rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,-10,0,0,0,0,0,10],
        0, 500)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-90,0,0,0],
        0, 500)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-90,0,0,0],
        0, 500)
    tail.wag_body(a, 500)
    a.rotate_array_callback(body.rotate.bind(body), [60], [0], 1500, 2000)
    a.rotate_array_callback(back_paw_rotate,
        [0,0,-10,0,0,0,0,0,10],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,90,0,0,-90,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,90,0,0,-90,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.finish(function() {
	show_buttons();
    })
    a.start()
    return a
}

window.standup_button_click = function() {
    stop_current(function() { standup(window.animate_speed) })
    hide_buttons()
}

window.turn = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    function dog_mesh_rotation(x) { dog_mesh.rotation.x = x }
    a.rotate_array_callback(dog_mesh_rotation, [0], [-Math.PI], 0, 500)
    function dog_mesh_position_y(y) { dog_mesh.position.y = y }
    a.rotate_array_callback(dog_mesh_position_y, [-4.8], [-6], 0, 500)
    function dog_mesh_position_z(z) { dog_mesh.position.z = z }
    a.rotate_array_callback(dog_mesh_position_z, [0], [-5], 0, 500)
    a.rotate_array_callback(body.rotate.bind(body), [5], [-2], 0, 500)
    a.rotate_array_callback(head_neck.rotate.bind(head_neck), [0], [-75], 0, 200)
    a.rotate_array_callback(head_neck.rotate.bind(head_neck), [-75], [-65], 400, 500)
    a.rotate_array_callback(tail.rotate,
        [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
        [0,50,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        0, 500)
    a.rotate_array_callback(brpaw.rotate,
        [30,-5,135,0,30,-110,0,0,0],
        [0,-20,75,0,0,-90,0,0,-10],
        0, 500)
    a.rotate_array_callback(blpaw.rotate,
        [-30,5,135,0,-30,-110,0,0,0],
        [0,20,75,0,0,-90,0,0,-10],
        0, 500)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,90,0,0,0,0,0,-50],
        [0,0,75,0,0,-90,0,0,-10],
        0, 500)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,90,0,0,0,0,0,-50],
        [0,0,75,0,0,-90,0,0,-10],
        0, 500)
    a.finish(function() {
        turned = true
	show_buttons();
	movingpaws()
    })
    a.start()
    return a
}

window.movingpaws = function(tm) {
    let a = movingpaws_animate = new Animate4
    if(tm) a.time_modifier = tm
        let period = 2000
    a.rotate_array_callback(flpaw.rotate,
        [0,0,75,0,0,-90,0,0,-10],
        [0,0,75,0,0,-130,0,0,-10],
        0, 500, period)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,75,0,0,-130,0,0,-10],
        [0,0,75,0,0,-50,0,0,-10],
        500, 1500, period)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,75,0,0,-50,0,0,-10],
        [0,0,75,0,0,-90,0,0,-10],
        1500, 2000, period)
    a.rotate_array_callback(brpaw.rotate,
        [0,-20,75,0,0,-90,0,0,-10],
        [0,-20,75,0,0,-130,0,0,-10],
        0, 500, period)
    a.rotate_array_callback(brpaw.rotate,
        [0,-20,75,0,0,-130,0,0,-10],
        [0,-20,75,0,0,-50,0,0,-10],
        500, 1500, period)
    a.rotate_array_callback(brpaw.rotate,
        [0,-20,75,0,0,-50,0,0,-10],
        [0,-20,75,0,0,-90,0,0,-10],
        1500, 2000, period)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,75,0,0,-90,0,0,-10],
        [0,0,75,0,0,-50,0,0,-10],
        0, 500, period)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,75,0,0,-50,0,0,-10],
        [0,0,75,0,0,-130,0,0,-10],
        500, 1500, period)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,75,0,0,-130,0,0,-10],
        [0,0,75,0,0,-90,0,0,-10],
        1500, 2000, period)
    a.rotate_array_callback(blpaw.rotate,
        [0,20,75,0,0,-90,0,0,-10],
        [0,20,75,0,0,-50,0,0,-10],
        0, 500, period)
    a.rotate_array_callback(blpaw.rotate,
        [0,20,75,0,0,-50,0,0,-10],
        [0,20,75,0,0,-130,0,0,-10],
        500, 1500, period)
    a.rotate_array_callback(blpaw.rotate,
        [0,20,75,0,0,-130,0,0,-10],
        [0,20,75,0,0,-90,0,0,-10],
        1500, 2000, period)
    a.start()
    return a
}

window.turnback = function(tm) {
    movingpaws_animate.exit_now = true
    movingpaws_animate = undefined
    let a = new Animate4
    if(tm) a.time_modifier = tm
    function dog_mesh_rotation(x) { dog_mesh.rotation.x = x }
    a.rotate_array_callback(dog_mesh_rotation, [-Math.PI], [0], 0, 500)
    function dog_mesh_position_y(y) { dog_mesh.position.y = y }
    a.rotate_array_callback(dog_mesh_position_y, [-6], [-4.8], 0, 500)
    function dog_mesh_position_z(z) { dog_mesh.position.z = z }
    a.rotate_array_callback(dog_mesh_position_z, [-5], [0], 0, 500)
    a.rotate_array_callback(body.rotate.bind(body), [-2], [5], 0, 500)
    a.rotate_array_callback(head_neck.rotate.bind(head_neck), [-65], [-75], 0, 200)
    a.rotate_array_callback(head_neck.rotate.bind(head_neck), [-75], [0], 200, 500)
    a.rotate_array_callback(tail.rotate,
        [0,50,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
        0, 500)
    a.rotate_array_callback(brpaw.rotate,
        [0,-20,75,0,0,-90,0,0,-10],
        [30,-5,135,0,30,-110,0,0,0],
        0, 500)
    a.rotate_array_callback(blpaw.rotate,
        [0,20,75,0,0,-90,0,0,-10],
        [-30,5,135,0,-30,-110,0,0,0],
        0, 500)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,75,0,0,-90,0,0,-10],
        [0,0,90,0,0,0,0,0,-50],
        0, 500)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,75,0,0,-90,0,0,-10],
        [0,0,90,0,0,0,0,0,-50],
        0, 500)
    a.finish(function() {
        turned = false
	show_buttons();
    })
    a.start()
    return a
}

window.turn_button_click = function() {
    hide_buttons()
    stop_current()
    if(!turned) turn(window.animate_speed)
    else turnback(window.animate_speed)
}

window.bone = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let time_from = 200
    let time_to = 800
    let time_final = 1600
    a.rotate_array_callback(head_neck.rotate.bind(head_neck), [0], [-100], time_from, time_to)
    let delta_x = dog_mesh.geometry.attributes.position.array[389*3+0]
    let delta_y = dog_mesh.geometry.attributes.position.array[389*3+1]
    let frpaw_footpoint = 222*3
    let leg_y = dog_mesh.geometry.attributes.position.array[frpaw_footpoint+1] - body.get_centre().y
    let leg_x = delta_x - body.get_centre().x
    let base_angle = Math.acos(leg_y / Math.sqrt(leg_y*leg_y + leg_x*leg_x))
    function dog_mesh_position() {
        let leg_y = dog_mesh.geometry.attributes.position.array[frpaw_footpoint+1] - body.get_centre().y
        let leg_x = dog_mesh.geometry.attributes.position.array[389*3+0] - body.get_centre().x
        let current_angle = Math.acos(leg_y / Math.sqrt(leg_y*leg_y + leg_x*leg_x))
	// console.log('c', current_angle, 'b', base_angle, 'd', current_angle - base_angle)
        body.rotate(THREE.MathUtils.radToDeg(current_angle - base_angle))
	dog_mesh.position.x = delta_x -
	    dog_mesh.geometry.attributes.position.array[389*3+0]
	dog_mesh.position.y = delta_y -
	    dog_mesh.geometry.attributes.position.array[389*3+1]
	// console.log(dog_mesh.position.x)
	if(!first_jaw_rotate_call) {
            bone_pivot.position.x = dog_mesh.position.x - 1.224 + bone_pivot_x
            bone_pivot.position.y = dog_mesh.position.y + 1.5 + bone_pivot_y
	}
    }
    function fpaw_rotate(a,b,c,d,e,f,g,h,i) {
	frpaw.rotate(a,b,c,d,e,f,g,h,i)
	flpaw.rotate(a,b,c,d,e,f,g,h,i)
	dog_mesh_position()
    }
    a.rotate_array_callback(fpaw_rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,20,0,0,-105,0,0,65],
        time_from, time_to)
    let first_jaw_rotate_call = true
    function jaw_rotate(angle_z) {
	if(first_jaw_rotate_call) {
	    first_jaw_rotate_call = false
	    jaw.calc_bases()
	}
	jaw.rotate(angle_z)
    }
    a.rotate_array_callback(jaw_rotate, [0], [-30], 800, 900)
    let second_jaw_rotate_call = true
    function second_jaw_rotate() {
	if(second_jaw_rotate_call) {
	    second_jaw_rotate_call = false
	    head_neck.calc_bases()
	}
    }
    a.rotate_array_callback(second_jaw_rotate, [0], [0], time_to+200, time_to+400)
    function bone_mesh_rotation(rz,px,py) {
	bone_pivot2.rotation.z = rz
	bone_mesh.position.x = px
	bone_mesh.position.y = py
    }
    a.rotate_array_callback(bone_mesh_rotation, [0,0,0], [-Math.PI*5/16,0,0.5], time_to+200, time_to+300)
    a.rotate_array_callback(bone_mesh_rotation, [-Math.PI*5/16,0,0.5], [-Math.PI/2-Math.PI/8,-0.6,0], time_to+300, time_to+400)
    a.rotate_array_callback(head_neck.rotate.bind(head_neck), [0], [100], time_to+200+200, time_final+200)
    a.rotate_array_callback(fpaw_rotate,
        [0,0,20,0,0,-105,0,0,65],
        [0,0,0,0,0,0,0,0,0],
        time_to+200+200, time_final+200)
    function bone_pivot_rotation(z) { bone_pivot.rotation.z = z }
    a.rotate_array_callback(bone_pivot_rotation, [0], [THREE.MathUtils.degToRad(100)], time_to+200+200, time_final+200)
    taken_bone = true
    a.start()
    return a
}

window.bone_button_click = function() {
    window.bone_mesh = bone_mesh_origin.clone()
    window.bone_pivot2 = new THREE.Object3D()
    window.bone_pivot2.add(window.bone_mesh)
    window.bone_pivot2.position.set(5.3 - bone_pivot_x, -6.6 - bone_pivot_y, 0)
    window.bone_pivot = new THREE.Object3D()
    window.bone_pivot.add(window.bone_pivot2)
    window.bone_pivot.position.set(bone_pivot_x, bone_pivot_y, 0)
    scene.add(window.bone_pivot)
    bone(window.animate_speed)
}

window.throw_bone = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    head.calc_bases()
    a.rotate_array_callback(head.rotate.bind(head), [0], [THREE.MathUtils.degToRad(45)], 0, 100)
    function bone_pivot_rotation(y) { bone_pivot.rotation.y = y }
    a.rotate_array_callback(bone_pivot_rotation, [0], [THREE.MathUtils.degToRad(30)], 0, 100)
    function bone_pivot_position(rz,py,pz) {
	bone_pivot2.rotation.z = THREE.MathUtils.degToRad(rz)
	bone_pivot.position.y = py
	bone_pivot.position.z = pz
    }
    a.rotate_array_callback(bone_pivot_position, [-112.5,0,0], [-100,-9.6,-3], 100, 500)
    let first_jaw_rotate_call = true
    function jaw_rotate(angle_z) {
	if(first_jaw_rotate_call) {
	    first_jaw_rotate_call = false
	    jaw.calc_bases()
	    // console.log(THREE.MathUtils.radToDeg(head.current_angle), head.z_axis)
	}
	jaw.rotate_axis(head.z_axis, THREE.MathUtils.degToRad(angle_z))
    }
    a.rotate_array_callback(jaw_rotate, [0], [30], 100, 250)
    let second_jaw_rotate_call = true
    function second_jaw_rotate() {
	if(second_jaw_rotate_call) {
	    second_jaw_rotate_call = false
	    head.calc_bases()
	}
    }
    a.rotate_array_callback(second_jaw_rotate, [0], [0], 250, 300)
    a.rotate_array_callback(head.rotate.bind(head), [0], [THREE.MathUtils.degToRad(-45)], 350, 500)
    thrown_bone = bone_pivot
    taken_bone = false
    thrown_bone_start_x = bone_pivot.position.x
    a.finish(function() {
        head.calc_bases()
        head_neck.calc_bases()
        jaw.calc_bases()
    })
    a.start()
    return a
}

window.throw_bone_button_click = function() {
    throw_bone(window.animate_speed)
}

  </script>
  <div align="centre" style="position:absolute;right:10px">
    <p><button id="go_stop_button" onclick="go_stop_button_click()">Пойдём</button></p>
    <p><button id="run_button" onclick="run_button_click()">Побежали</button></p>
    <p><button id="tail_wag_button" onclick="tail_wag_button_click()">:)</button></p>
    <p id="stop_all_par" style="display:none"><button id="stop_all_button" onclick="stop_all_button_click()">Замри</button></p>
    <p><button id="sit_stand_button" onclick="sit_stand_button_click()">Сидеть</button></p>
    <p id="liedown_par" style="display:none"><button id="liedown_button" onclick="liedown_button_click()">Лежать</button></p>
    <p><button id="paw_button" onclick="paw_button_click()">Лапу</button></p>
    <p><button id="standup_button" onclick="standup_button_click()">Вверх</button></p>
    <p><button id="turn_button" style="display:none" onclick="turn_button_click()">Поворот</button></p>
    <p><button id="bone_button" onclick="bone_button_click()">Косточка</button></p>
    <p><button id="bone_button" onclick="throw_bone_button_click()">Брось косточку</button></p>
  </div>
</body>
</html>
