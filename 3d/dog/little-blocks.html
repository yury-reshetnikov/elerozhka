<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Рисуем собакена</title>
  <script src="https://threejs.org/build/three.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="three-animate.js"></script>
  <script src="dog-paw.js"></script>
</head>
<body>
  <script type="module">
    import { GLTFLoader } from 'https://threejs.org/examples/jsm/loaders/GLTFLoader.js'

let sitting = false
let lying = false
let paw_up = false
let left_paw = false

let scene = new THREE.Scene()
let camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 )

let renderer = new THREE.WebGLRenderer()
renderer.setSize( window.innerWidth * 0.9, window.innerHeight * 0.9 )
renderer.setClearColor( 0xffffff, 1 )
document.body.appendChild( renderer.domElement )
renderer.shadowMap.enabled = true
scene.add(new THREE.AmbientLight(0xffffff, 0.6))
let point_light = new THREE.PointLight(0xffffff, 0.5)
// let point_light = new THREE.DirectionalLight(0xffffff, 5)
point_light.position.set( -500, 700, 300 )
point_light.castShadow = true
point_light.shadow.camera.far = 5000
scene.add(point_light)

function euler_xyz(quat) {
    let euler = (new THREE.Euler()).setFromQuaternion(quat, 'XYZ')
    function a(v) { return Math.round(THREE.MathUtils.radToDeg(v)) }
    return [a(euler.x), a(euler.y), a(euler.z)]
}

function lip(g, ind, base_i, prev_i) { // linked index points
    let next = []
    let base = base_i.map(function(p) { return ind[p] })
    let prev = prev_i.map(function(p) { return ind[p] })
    for(let t = 0; t < g.index.count; t = t + 3) {
	if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
	    for(let i = t; i < t + 3; ++i) {
		let p = ind[i]
		if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
		    next.push(p)
	    }
    }
    let next_i = []
    ind.forEach(function(p,i) { if(next.includes(p)) next_i.push(i) })
    next_i.sort((a,b)=>a-b)
    return next_i
}

function lp(g, base, prev) { // linked points
    let ind = g.index.array
    let next = []
    for(let t = 0; t < g.index.count; t = t + 3) {
	if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
	    for(let i = t; i < t + 3; ++i) {
		let p = ind[i]
		if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
		    next.push(p)
	    }
    }
    next.sort((a,b)=>a-b)
    return next
}

function lp_eq_y(g, base, prev) {
    let next = []
    let y = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, base[0]).y
    lp(g, base, prev).forEach(function(p) {
	if((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p).y == y) next.push(p)
    })
    return next
}

function lp_lt_y(g, base, prev) {
    let next = []
    let y = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, base[0]).y
    lp(g, base, prev).forEach(function(p) {
	if((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p).y < y) next.push(p)
    })
    return next
}

function range(start, length) {
    return Array.from({length:length},(v,k)=>start+k)
}
function ri(ind, start, length) { // Range Index
    return range(start, length).map(i=>ind[i])
}
function rp(exclude, ind) { // Range points
    let res1 = []
    for(let i = 1; i < arguments.length; ) {
	let start = arguments[++i]
	let length = arguments[++i]
	res1.push(ri(ind, start, length))
    }
    res1 = res1.flat()
    res1.sort((a,b)=>a-b)
    let res = []
    res1.forEach(function(v) {
	if(!res.length || res[res.length-1] != v)
	    if(!exclude.includes(v))
		res.push(v)
    })
    return res
}

function calc_center(list) {
    let pos = window.dog.attributes.position.array
    if(list.length == 0) return
    else if(list.length == 1) {
	let a = list[0] * 3
	return Array.from(pos.slice(a, a + 3))
    }
    else {
	let s = [0,0,0]
	list.forEach(function(item) {
	    let a = item * 3
	    for(let i = 0; i < 3; ++i,++a) s[i] = s[i] + pos[a]
	})
	return s.map((v) => v / list.length)
    }
}

window.tail = {
    points: [
	[342],
    ],
    bases: [], // 0..6
    delta: 0.2,
    init: function() {
	let g = window.dog
	let ind = g.index.array
	let pos = g.attributes.position.array
	function lp(base, prev) { // linked points
	    let next = []
	    for(let t = 0; t < g.index.count; t = t + 3) {
		if(base.includes(ind[t]) || base.includes(ind[t+1]) || base.includes(ind[t+2]))
		    for(let i = t; i < t + 3; ++i) {
			let p = ind[i]
			if(!base.includes(p) && !prev.includes(p) && !next.includes(p))
			    next.push(p)
		    }
	    }
	    next.sort((a,b)=>a-b)
	    return next
	}
	tail.points.push(lp(tail.points[tail.points.length-1], []))
	for(let i = 2; i < 14; ++i)
	    tail.points.push(lp(tail.points[tail.points.length-1],
				tail.points[tail.points.length-2]))
	// считаем bases
	let prev_rc
	let centers = tail.centers()
	for(let s = 0; s < 6; ++s) {
	    let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centers[s*2]), (new THREE.Vector3()).fromArray(centers[s*2+1]))
	    let angle = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize()).conjugate()
	    let rc = (new THREE.Vector3()).fromArray(tail.rotation_center(centers, s))
	    let bases_points = []
	    for(let n = 1; n >= 0; --n) {
		tail.points[s*2+n].forEach(function(p) {
		    let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), rc).applyQuaternion(angle)
		    bases_points.push(v.x, v.y, v.z)
		})
	    }
	    if(s) {
		let v = (new THREE.Vector3()).subVectors(prev_rc, rc).applyQuaternion(angle)
		bases_points.push(v.x, v.y, v.z)
	    }
	    tail.bases.push(bases_points)
	    prev_rc = rc
	}
	// bases[6]
	{
	    let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centers[12]), (new THREE.Vector3()).fromArray(centers[13]))
	    let angle = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize()).conjugate()
	    let rc = (new THREE.Vector3()).fromArray(centers[13])
	    let bases_points = []
	    tail.points[12].forEach(function(p) {
		let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), rc).applyQuaternion(angle)
		bases_points.push(v.x, v.y, v.z)
	    })
	    {   let v = (new THREE.Vector3()).subVectors(prev_rc, rc).applyQuaternion(angle)
		bases_points.push(v.x, v.y, v.z)
	    }
	    tail.bases.push(bases_points)
	}
	tail.current_angles = [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30]
    },
    calc_center: function(list) {
	let pos = window.dog.attributes.position.array
	if(list.length == 0) return
	else if(list.length == 1) {
	    let a = list[0] * 3
	    return Array.from(pos.slice(a, a + 3))
	}
	else {
	    let s = [0,0,0]
	    list.forEach(function(item) {
		let a = item * 3
		for(let i = 0; i < 3; ++i,++a) s[i] = s[i] + pos[a]
	    })
	    return s.map((v) => v / list.length)
	}
    },
    centers: function() {
	return tail.points.map(tail.calc_center)
    },
    rotation_center: function(centers, n) {
	function leg(a,b,c,d) {
	    return Math.pow(centers[a][b] - centers[c][d], 2)
	}
	let s0 = n * 2, s1 = s0+1
	let len0 = Math.sqrt(leg(s0, 0, s1, 0) +
			     leg(s0, 1, s1, 1) +
			     leg(s0, 2, s1, 2))
	// rc === Rotation Center
	let rc0 = []
	for(let i = 0; i < 3; ++i)
	    rc0[i] = centers[s1][i] +
	    (centers[s1][i] - centers[s0][i]) * tail.delta / len0
	return rc0
    },
}

let loader = new GLTFLoader()
loader.load('little-blocks-conv.glb', function(gltf) {
    // console.log(gltf)
    let mesh = gltf.scene.children[0]
    // mesh.scale.set(10, 10, 10)
    let material = new THREE.MeshStandardMaterial({ color: 0x97612f })
    let material_red = new THREE.MeshStandardMaterial({ color: 0xff0000 })
    let material_black = new THREE.MeshStandardMaterial({ color: 0x000000 })
    let material_almostblack = new THREE.MeshStandardMaterial({ color: 0x190707 })
    mesh.material = [material, material_red, material_black, material_almostblack]
    mesh.castShadow = true
    mesh.geometry.addGroup(0, 54, 0)
    mesh.geometry.addGroup(54, 12, 3) // левый глаз
    mesh.geometry.addGroup(66, 30, 0)
    mesh.geometry.addGroup(96, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(99, 3, 0)
    mesh.geometry.addGroup(102, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(105, 3, 0)
    mesh.geometry.addGroup(108, 3, 0)
    mesh.geometry.addGroup(111, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(114, 6, 0)
    mesh.geometry.addGroup(120, 3, 3) // часть правого глаза
    mesh.geometry.addGroup(123, 57, 0)
    mesh.geometry.addGroup(180, 9, 0)
    mesh.geometry.addGroup(189, 3, 3) // пятачок
    mesh.geometry.addGroup(192, 3, 3) // нос
    mesh.geometry.addGroup(195, 9, 3) // пятачок
    mesh.geometry.addGroup(204, 9, 3) // нос
    mesh.geometry.addGroup(213, 27, 0)
    mesh.geometry.addGroup(240, 24, 3) // нос
    mesh.geometry.addGroup(264, 3, 0)
    mesh.geometry.addGroup(267, 6, 3) // нос
    mesh.geometry.addGroup(273, 78, 0)
    mesh.geometry.addGroup(351, 33, 0) // передняя часть цилиндра тела
    mesh.geometry.addGroup(384, 183, 0)
    mesh.geometry.addGroup(567, 21, 0) // часть ноги
    mesh.geometry.addGroup(588, 3, 0)
    mesh.geometry.addGroup(591, 3, 0) // часть ноги
    mesh.geometry.addGroup(594, 12, 0)
    mesh.geometry.addGroup(606, 27, 0) // задняя часть цилиндра тела
    mesh.geometry.addGroup(633, 39, 0)
    mesh.geometry.addGroup(672, 3, 0) // начало левой задней ноги 2.0
    mesh.geometry.addGroup(675, 3, 0)
    mesh.geometry.addGroup(678, 3, 0) // начало левой задней ноги 2.0
    mesh.geometry.addGroup(681, 3, 0)
    mesh.geometry.addGroup(684, 6, 0) // начало левой задней ноги 2.0
    mesh.geometry.addGroup(690, 3, 0)
    mesh.geometry.addGroup(693, 6, 0) // начало левой задней ноги 2.0
    mesh.geometry.addGroup(699, 3, 0)
    mesh.geometry.addGroup(702, 6, 0) // начало левой задней ноги 2.0
    mesh.geometry.addGroup(708, 6, 0)
    mesh.geometry.addGroup(714, 534, 0)
    mesh.geometry.addGroup(1248, 90, 0) // попа
    mesh.geometry.addGroup(1338, 12, 0)
    mesh.geometry.addGroup(1350, 9, 0) // попа
    mesh.geometry.addGroup(1359, 3, 0)
    mesh.geometry.addGroup(1362, 3, 0) // попа
    mesh.geometry.addGroup(1365, 9, 0)
    // mesh.geometry.addGroup(1374, 51, 0) // попа
    mesh.geometry.addGroup(1374, 39, 0)
    mesh.geometry.addGroup(1413, 24, 0) // начало правой задней ноги 2.0
    mesh.geometry.addGroup(1437, 12, 0)
    mesh.geometry.addGroup(1449, 51, 0) // попа
    mesh.geometry.addGroup(1500, 120, 0)
    mesh.geometry.addGroup(1620, 24, 0) // конус кончика хвоста
    mesh.geometry.addGroup(1644, 960, 0)
    scene.add(mesh)
    window.dog = mesh.geometry
    window.dog_mesh = mesh
    tail.init()
    window.tail = tail
    window.frpaw = new Paw(mesh.geometry, [207, 210, 217]) // front right paw
    window.flpaw = new Paw(mesh.geometry, [174, 176, 184])
    window.brpaw = new Paw(mesh.geometry, [376, 377, 420]) // back right paw
    window.blpaw = new Paw(mesh.geometry, [367, 368, 383])
    window.rare = new Rare()
    window.body = new Body()
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    // // нос
    // console.log(lip(g, ind, [189,190,191,195,196,197,198,199,200,201,202,203], []))
    // правая передняя нога

    // console.log(ri(ind, 1350, 9))
    if(0) {
        console.log(rp([window.tail.points[13],
		    window.brpaw.get_points()[6],
		    window.blpaw.get_points()[6],
		   ].flat(), ind,
		   351, 33, 606, 27, // цилиндр тела
		   1248, 90, // попа
		   1350, 9, // попа
		   1362, 3, // попа
		   1374, 51, // попа
		   1449, 51, // попа
		  ))
    }
    // console.log((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, 342))
    if(0) rare.points.forEach(function(p) {
	let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
	if(v.x <= -5.29 && v.x >= -5.31 && v.y >= 0.69) console.log('p', p, 'v', v)
    })
    // console.log(tail.points)
    if(0) tail.points[1].forEach(function(p) {
	let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
	console.log(p, v.x)
    })

    if(0) {
    // ind[567] == 106
    console.log(ind[567],
		(new THREE.Vector3()).fromBufferAttribute(g.attributes.position, ind[567]),
		lp(g, [106, 107, 116], []),
		lp_eq_y(g, [106, 107, 109, 110, 112, 113, 115, 116], []),
		lp_lt_y(g, [106, 107, 109, 110, 112, 113, 115, 116], []),
		lp(g, [108, 111, 114, 117, 201, 202, 203, 204], [106, 107, 109, 110, 112, 113, 115, 116]))
    let paw = [[106, 107, 109, 110, 112, 113, 115, 116],
	       [108, 111, 114, 117, 201, 202, 203, 204]
	      ]
    for(;;) {
	let next = lp(g, paw[paw.length - 1], paw[paw.length - 2])
	if(!next.length) break
	paw.push(next)
	console.log(next)
    }
    console.log((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, 209))
    console.log(g.attributes.position.count)
    for(let p = 0; p < g.attributes.position.count; ++p) {
        let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
        if(v.y > -6.86 && v.y < -6.84) console.log (p, v)
    }
    //console.log(g)
    }
    if(0) { // ищем базовые точки для ступней
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if(v.y == -7 && (v.z == 1 || v.z == -1 || (v.z > 0.759 && v.z < 0.761) || (v.z < -0.759 && v.z > -0.761))) console.log (p, v)
	}
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if(v.y > -6.86 && v.y < -6.84 && (v.z == 1 || v.z == -1 || (v.z > 0.759 && v.z < 0.761) || (v.z < -0.759 && v.z > -0.761))) console.log ('+', p, v)
	}
    }
    if(0) { // ищем туловище
	let n = 0
	for(let p = 0; p < g.attributes.position.count; ++p) {
            let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
            if((v.x > 0.62 && v.x < 0.66) || (v.x > -3.1 && v.x < -2.9)) console.log (++n, p, v)
	}
    }
})

function Rare() {
    // 233, 238, 254 - спина попы
    this.points = [230, 231, 232, 233, 234, 235, 236, 237, 238, 240, 254, 255, 258, 259, 260, 261]
    let center = new THREE.Vector3(-4, -0.3, 0) // -5.5, -0.4, 0
    let bases
    this.current_angle = 0
    let g = window.dog
    this.points = this.points.concat(tail.points.flat()).concat(brpaw.get_points().flat()).concat(blpaw.get_points().flat())
    this.calc_bases = function() {
	bases = []
	this.points.forEach(function(p) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), center)
            bases.push(v.x, v.y, v.z)
	})
    }
    this.calc_bases()
    this.rotate = function(angle_z) {
        this.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(center, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
        g.attributes.position.needsUpdate = true
    }
    this.get_center = function() { return center }
}

function Body() {
    // были удалены точки 81 и 82
    this.points = [69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 117, 118, 119, 120]
    let center = new THREE.Vector3(2, -1.2, 0)
    let bases = []
    this.current_angle = 0
    let g = window.dog
    this.points = this.points.concat(tail.points.flat()).concat(brpaw.get_points().flat()).concat(blpaw.get_points().flat()).concat(rare.points)
    this.points.forEach(function(p) {
        let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), center)
        bases.push(v.x, v.y, v.z)
    })
    function paw_bases(paw) {
        let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(paw.get_base_rotation_center()), center)
        return [v.x, v.y, v.z]
    }
    this.calc_paw_bases = function() {
	this.brpaw_bases = paw_bases(brpaw)
	this.blpaw_bases = paw_bases(blpaw)
    }
    this.calc_paw_bases()
    let rare_center_base = (new THREE.Vector3()).subVectors(rare.get_center(), center)
    this.rotate = function(angle_z) {
        this.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	this.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(center, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
	function paw_center(paw, bases) {
	    let v = (new THREE.Vector3()).fromArray(bases).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(center, v)
	    let rc = paw.get_base_rotation_center()
	    rc[0] = d.x
	    rc[1] = d.y
	    rc[2] = d.z
	}
	paw_center(brpaw, this.brpaw_bases)
	paw_center(blpaw, this.blpaw_bases)
	rare.get_center().copy((new THREE.Vector3()).addVectors(center, (new THREE.Vector3()).copy(rare_center_base).applyQuaternion(angle)))
	rare.calc_bases()
        g.attributes.position.needsUpdate = true
    }
}

/*
window.body = {
    points: [69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 119, 120, 121, 122, 232, 233, 234, 235, 236, 237, 238, 239, 240, 242, 256, 257, 260, 261, 262, 263],
    center: new THREE.Vector3(2, -0.6, 0),
    bases: [],
    current_angle: 0,
    init: function() {
	let g = window.dog
	body.points = body.points.concat(tail.points.flat()).concat(brpaw.get_points().flat()).concat(blpaw.get_points().flat())
        body.points.forEach(function(p) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), body.center)
            body.bases.push(v.x, v.y, v.z)
        })
	function paw_bases(paw) {
            let v = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(paw.get_base_rotation_center()), body.center)
            return [v.x, v.y, v.z]
	}
	body.brpaw_bases = paw_bases(brpaw)
	body.blpaw_bases = paw_bases(blpaw)
    },
    rotate: function(angle_z) {
	let g = window.dog
        body.current_angle = angle_z
        let angle = (new THREE.Quaternion()).setFromEuler(new THREE.Euler(0,0,THREE.MathUtils.degToRad(angle_z),'XYZ'))
	body.points.forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(body.bases, i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(body.center, v)
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	})
	function paw_center(paw, bases) {
	    let v = (new THREE.Vector3()).fromArray(bases).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(body.center, v)
	    let rc = paw.get_base_rotation_center()
	    rc[0] = d.x
	    rc[1] = d.y
	    rc[2] = d.z
	}
	paw_center(brpaw, body.brpaw_bases)
	paw_center(blpaw, body.blpaw_bases)
        g.attributes.position.needsUpdate = true
    },
}
*/

let loadManager = new THREE.LoadingManager()
let texture_loader = new THREE.TextureLoader(loadManager)

let tiles = []

loader.load('tile.glb', function(gltf) {
    let mesh = gltf.scene.children[1]
    let material = new THREE.MeshStandardMaterial({/* color: 0x404030,*/ map: texture_loader.load('texture.jpg')})
    mesh.material = material
    //let texture = loader.load('../elerozhka/3d/dog/texture.jpg')
    mesh.receiveShadow = true
    // mesh.position.set(0,-7,0)
    // scene.add(mesh)
    for(let x = -20; x <= 20; ++x)
	for(let y = -4; y <= 4; ++y) {
	    let mesh1 = mesh.clone()
	    mesh1.position.set(x * 3.42, -7, y * 2 * 1.666)
	    scene.add(mesh1)
	    tiles.push({x: mesh1.position.x, y: mesh1.position.y, z: mesh1.position.z, m: mesh1})
	    let mesh2 = mesh.clone()
	    mesh2.position.set(x * 3.42 + 1.71, -7, (y * 2 + 1) * 1.666)
	    scene.add(mesh2)
	    tiles.push({x: mesh2.position.x, y: mesh2.position.y, z: mesh2.position.z, m: mesh2})
	}
})

camera.position.set(-4, 0, 14)
let controls = new THREE.OrbitControls( camera, renderer.domElement )

function animate() {
    requestAnimationFrame( animate )
    renderer.render( scene, camera )
}
animate()

let tile_delta_x = 0
function dog_updown(y) {
    dog_mesh.position.y = y
}

window.go = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let period = 1000
    let one = function(paw) {
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,0,0,0,0],
          [0,0,10,0,0,-35,0,0,20],
          100, 200)
    a.rotate_array_callback(paw.rotate,
          [0,0,10,0,0,-35,0,0,20],
          [0,0,20,0,0,-55,0,0,20],
          200, 300)
    a.rotate_array_callback(paw.rotate,
          [0,0,20,0,0,-55,0,0,20],
          [0,0,25,0,0,0,0,0,-25],
          300, 500, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,25,0,0,0,0,0,-25],
          [0,0,0,0,0,0,0,0,0],
          500, 750, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,0,0,0,0],
          [0,0,-25,0,0,0,0,0,15],
          750, 1000, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,-25,0,0,0,0,0,15],
          [0,0,0,0,0,-55,0,0,20],
          1000, 1100, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,-55,0,0,20],
          [0,0,20,0,0,-55,0,0,20],
	  1100, 1300, period)
    }
    let two = function(paw) {
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,0,0,0,0],
          [0,0,-25,0,0,0,0,0,15],
          300, 550, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,-25,0,0,0,0,0,15],
          [0,0,0,0,0,-55,0,0,20],
          550, 650, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,0,0,0,-55,0,0,20],
          [0,0,20,0,0,-55,0,0,20],
	  650, 850, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,20,0,0,-55,0,0,20],
          [0,0,25,0,0,0,0,0,-25],
          850, 1050, period)
    a.rotate_array_callback(paw.rotate,
          [0,0,25,0,0,0,0,0,-25],
          [0,0,0,0,0,0,0,0,0],
          1050, 1300, period)
    }
    one(frpaw)
    one(blpaw)
    two(flpaw)
    two(brpaw)
    let tile_start = 300
    let tile_period = 417.68
    a.rotate_array_callback(function(x) {
        tiles.forEach(function(tile) {
            tile.m.position.x = tile.x + tile_delta_x - x
        })
    },
    [0], [3.42], tile_start, tile_start + tile_period, tile_period
    )
    a.rotate_array_callback(dog_updown, [0], [-0.4], 300, 550, 500)
    a.rotate_array_callback(dog_updown, [-0.4], [0], 550, 800, 500)
    a.rotate_array_callback(tail.rotate, [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
                                         [0,8,0,-9,0,-25,0,-20,0,-45,0,-35,0,-20],
                                         300, 400, 500)
    a.rotate_array_callback(tail.rotate, [0,8,0,-9,0,-25,0,-20,0,-45,0,-35,0,-20],
                                         [0,8,0,-9,0,-25,0,-20,0,-45,0,-55,0,-40],
                                         400, 600, 500)
    a.rotate_array_callback(tail.rotate, [0,8,0,-9,0,-25,0,-20,0,-45,0,-55,0,-40],
                                         [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
                                         600, 800, 500)
    a.start()
    return a
}

window.stop = function(a, fincb) {
    a.exit_now = true
    tile_delta_x = tiles[0].m.position.x - tiles[0].x
    let b = new Animate4;
    [frpaw,flpaw,brpaw,blpaw].forEach(function(paw) {
	b.rotate_array_callback(paw.rotate,
				[...paw.current_angles()],
				[0,0,0,0,0,0,0,0,0],
				0, 200)
    })
    b.rotate_array_callback(dog_updown, [dog_mesh.position.y], [0], 0, 200)
    b.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        0, 200)
    if(fincb) b.finish(fincb)
    b.start()
}

window.correct_tail = function() {
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centers = tail.centers()
    function leg(a,b,c,d) {
	return Math.pow(centers[a][b] - centers[c][d], 2)
    }
    function check_segment(n) {
	let s0 = n * 2, s1 = s0+1, s2 = s0+2, s3 = s0+3
	let len0 = Math.sqrt(leg(s0, 0, s1, 0) +
			     leg(s0, 1, s1, 1) +
			     leg(s0, 2, s1, 2))
	let len1 = Math.sqrt(leg(s2, 0, s3, 0) +
			     leg(s2, 1, s3, 1) +
			     leg(s2, 2, s3, 2))
	// rp === Rotation Center
	let rc0 = []
	for(let i = 0; i < 3; ++i)
	    rc0[i] = centers[s1][i] +
	    (centers[s1][i] - centers[s0][i]) * tail.delta / len0
	let rc0a = []
	for(let i = 0; i < 3; ++i)
	    rc0a[i] = centers[s2][i] -
	    (centers[s3][i] - centers[s2][i]) * tail.delta / len1
	let m = []
	for(let i = 0; i < 3; ++i) m[i] = rc0a[i] - rc0[i]
	return m
    }
    function mp(m, c) { // Move Points
	// console.log(m)
	for(let a = 0; a < c; ++a)
	    for(let b = 0; b < tail.points[a].length; ++b) {
		let p = tail.points[a][b] * 3
		for(let i = 0; i < 3; ++i,++p)
		    pos[p] = pos[p] + m[i]
	    }
    }
    for(let i = 0; i < 6; ++i)
	mp(check_segment(i), (i+1)*2)
    g.attributes.position.needsUpdate = true
}

window.get_angles = function() {
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centers = tail.centers()
    // console.log('centers.length', centers.length)
    let angles = []
    function a(v) { return Math.round(THREE.MathUtils.radToDeg(v)) }
    for(let s = 0; s < 6; ++s) {
	let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centers[s*2]), (new THREE.Vector3()).fromArray(centers[s*2+1]))
	let pre = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centers[(s+1)*2]), (new THREE.Vector3()).fromArray(centers[(s+1)*2+1]))
	// console.log('s', s, 'cur', cur, 'pre', pre)
	let angle = (new THREE.Euler()).setFromQuaternion((new THREE.Quaternion()).setFromUnitVectors(pre.normalize(), cur.normalize()), 'XYZ')
	let angle2 = (new THREE.Euler()).setFromQuaternion((new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize()), 'XYZ')
	angles.push([a(angle.x), a(angle.y), a(angle.z), a(angle2.x), a(angle2.y), a(angle2.z)])
    }
    /*
    console.log(tail.points[13])
    tail.points[13].forEach(function(p){
	let v = (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p)
	console.log('p', p, 'v', v, 'pos', pos[p*3], pos[p*3+1], pos[p*3+2])
    })
    */
    // 3 - 248 - верх | 4 - 251 - максимально положительная z
    let up = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][3]), (new THREE.Vector3()).fromArray(centers[13]))
    let side = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][4]), (new THREE.Vector3()).fromArray(centers[13]))
    let a1 = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(0,-1,0), up.normalize())
    // в начальном состоянии собакена нет поворота вокруг вектора up, поэтому пока не будем учитывать поворот для вектора side. его надо будет учесть, когда научим собакена вилять всей попой.
    let a1e = (new THREE.Euler()).setFromQuaternion(a1, 'XYZ')
    let cur = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromArray(centers[12]), (new THREE.Vector3()).fromArray(centers[13]))
    let c1 = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(1,0,0), cur.normalize())
    // c1 = a1 * c2
    let c2 = c1.clone().multiply(a1.conjugate())
    let angle = (new THREE.Euler()).setFromQuaternion(c2, 'XYZ')
    let angle2 = (new THREE.Euler()).setFromQuaternion(c1, 'XYZ')
    angles.push([a(angle.x), a(angle.y), a(angle.z), a(angle2.x), a(angle2.y), a(angle2.z)])
    angles.push([a(a1e.x), a(a1e.y), a(a1e.z)])
    return angles
}

window.rotate_tail_v1 = function(segment, angle_hor, angle_vert){
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centers = tail.centers()
    let rc = tail.rotation_center(centers, segment)
    let angle_center = centers[segment * 2]
    // console.log('rc:', rc, 'ac:', angle_center); return;
    function ang(yz) {
	let x1 = angle_center[0] - rc[0]
	let y1 = angle_center[yz] - rc[yz]
	if(x1 == 0 && y1 == 0) return 0
	let g = Math.sqrt(x1*x1 + y1*y1)
	let a0 = Math.asin(y1 / g)
	if(x1 < 0) a0 = Math.PI - a0
	return a0 * 180 / Math.PI
    }
    angle_hor = angle_hor - ang(2)
    angle_vert = angle_vert - ang(1)
    let c = (segment+1)*2
    for(let a = 0; a < c; ++a)
	for(let b = 0; b < tail.points[a].length; ++b) {
	    let p = tail.points[a][b] * 3
	    function rot(yz, angle) {
		let x1 = pos[p] - rc[0]
		let y1 = pos[p+yz] - rc[yz]
		let g = Math.sqrt(x1*x1 + y1*y1)
		let a0 = x1 == 0 && y1 == 0 ? 0 : Math.asin(y1 / g)
		if(x1 < 0) a0 = Math.PI - a0
		let a1 = a0 + angle * Math.PI / 180
		pos[p] = rc[0] + g * Math.cos(a1)
		pos[p+yz] = rc[yz] + g * Math.sin(a1)
	    }
	    rot(2, angle_hor)
	    rot(1, angle_vert)
	}
    g.attributes.position.needsUpdate = true
}

window.rotate_tail_base = function(angle_hor, angle_vert){
    let g = window.dog
    let ind = g.index.array
    let pos = g.attributes.position.array
    let centers = tail.centers()
    let rc = centers[13]
    let angle_center = centers[12]
    function ang(yz) {
	let x1 = angle_center[0] - rc[0]
	let y1 = angle_center[yz] - rc[yz]
	if(x1 == 0 && y1 == 0) return 0
	let g = Math.sqrt(x1*x1 + y1*y1)
	let a0 = Math.asin(y1 / g)
	if(x1 < 0) a0 = Math.PI - a0
	return a0 * 180 / Math.PI
    }
    angle_hor = angle_hor - ang(2)
    angle_vert = angle_vert - ang(1)
    for(let a = 0; a < 13; ++a)
	for(let b = 0; b < tail.points[a].length; ++b) {
	    let p = tail.points[a][b] * 3
	    function rot(yz, angle) {
		let x1 = pos[p] - rc[0]
		let y1 = pos[p+yz] - rc[yz]
		let g = Math.sqrt(x1*x1 + y1*y1)
		let a0 = x1 == 0 && y1 == 0 ? 0 : Math.asin(y1 / g)
		if(x1 < 0) a0 = Math.PI - a0
		let a1 = a0 + angle * Math.PI / 180
		pos[p] = rc[0] + g * Math.cos(a1)
		pos[p+yz] = rc[yz] + g * Math.sin(a1)
	    }
	    rot(2, angle_hor)
	    rot(1, angle_vert)
	}
    g.attributes.position.needsUpdate = true
}

// начальное состояние
// rotate_tail(0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30)
tail.rotate = function() {
    tail.current_angles = [...arguments]
    let g = window.dog
    let pos = g.attributes.position.array
    let angle
    let rc = (new THREE.Vector3()).fromArray(tail.calc_center(tail.points[13]))
    {
	let up = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][3]), rc)
	// console.log('rc', rc, 'up', up, '13_3', tail.points[13][3], 'v', (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][3]))
	let side = (new THREE.Vector3()).subVectors((new THREE.Vector3()).fromBufferAttribute(g.attributes.position, tail.points[13][4]), rc)
	angle = (new THREE.Quaternion()).setFromUnitVectors(new THREE.Vector3(0,-1,0), up.normalize())
	// в начальном состоянии собакена нет поворота вокруг вектора up, поэтому пока не будем учитывать поворот для вектора side. его надо будет учесть, когда научим собакена вилять всей попой.
	// console.log('angle', angle, euler_xyz(angle))
    }
    {
	let euler = new THREE.Euler(0, THREE.MathUtils.degToRad(arguments[0]), THREE.MathUtils.degToRad(arguments[1]), 'XYZ')
	angle = angle.multiply((new THREE.Quaternion()).setFromEuler(euler))
	tail.points[12].forEach(function(p,i) {
	    let v = (new THREE.Vector3()).fromArray(tail.bases[6], i*3).applyQuaternion(angle)
	    let d = (new THREE.Vector3()).addVectors(rc, v)
	    // console.log('i', i, 'p', p, 'old', (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), 'new', d, 'v', v, 'rc', rc, 'angle', angle, euler_xyz(angle))
	    g.attributes.position.setXYZ(p, d.x, d.y, d.z)
	    // let pi = p * 3
	    // pos[pi] = d.x
	    // pos[++pi] = d.y
	    // pos[++pi] = d.z
	})
	{
	    let v = (new THREE.Vector3()).fromArray(tail.bases[6], 8*3).applyQuaternion(angle)
	    rc = (new THREE.Vector3()).addVectors(rc, v)
	}
    }
    // g.attributes.position.needsUpdate = true
    // return
    for(let s = 5; s >= 0; --s) {
	let euler = new THREE.Euler(0, THREE.MathUtils.degToRad(arguments[(6-s)*2]), THREE.MathUtils.degToRad(arguments[(6-s)*2+1]), 'XYZ')
	angle = angle.multiply((new THREE.Quaternion()).setFromEuler(euler))
	for(let n = 0; n < 2; ++n) {
	    tail.points[s*2+n].forEach(function(p,i) {
		let v = (new THREE.Vector3()).fromArray(tail.bases[s],
			((1-n)*8+i)*3).applyQuaternion(angle)
		let d = (new THREE.Vector3()).addVectors(rc, v)
		// if(!s) console.log('n', n, 'i', i, 'p', p, 'old', (new THREE.Vector3()).fromBufferAttribute(g.attributes.position, p), 'new', d, 'v', v, 'rc', rc, 'angle', angle, euler_xyz(angle))
		g.attributes.position.setXYZ(p, d.x, d.y, d.z)
		// let pi = p * 3
		// pos[pi] = d.x
		// pos[++pi] = d.y
		// pos[++pi] = d.z
	    })
	}
	if(s) {
	    let v = (new THREE.Vector3()).fromArray(tail.bases[s], 16*3).applyQuaternion(angle)
	    rc = (new THREE.Vector3()).addVectors(rc, v)
	}
    }
    g.attributes.position.needsUpdate = true
}

tail.wag = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    if(sitting) {
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0], [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], 100, 400)
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], [0,-40,0,0,-10,0,-20,0,-30,0,-40,0,-50,0], 400, 800, 800)
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,-10,0,-20,0,-30,0,-40,0,-50,0], [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], 800, 1200, 800)
        a.rotate_array_callback(tail.rotate, [0,-40,0,0,10,0,20,0,30,0,40,0,50,0], [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0], 1200, 1500)
    }
    else if(lying) {
        a.rotate_array_callback(tail.rotate, [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0], [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], 100, 400)
        a.rotate_array_callback(tail.rotate, [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], [0,90,0,20,10,-55,20,-10,30,-10,40,0,50,0], 400, 800, 800)
        a.rotate_array_callback(tail.rotate, [0,90,0,20,10,-55,20,-10,30,-10,40,0,50,0], [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], 800, 1200, 800)
        a.rotate_array_callback(tail.rotate, [0,90,0,20,-10,-55,-20,-10,-30,-10,-40,0,-50,0], [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0], 1200, 1500)
    }
    else {
	let base    = [  0,8, 0, -9,  0,-25,  0,-20, 0,-45, 0,-45, 0,-30]
	let quarter = [2.5,8, 5, -9,2.5,-25,7.5,-20, 5,-45,10,-40,10,-27]
	// [2.5,6, 5,-9.25,2.5,-21.25,7.5,-20, 5,-38.75,10,-38.75,10,-25],
	let half    = [  5,8,10, -9,  5,-25, 15,-20,10,-45,20,-30,20,-20]
	let full    = [ 10,0,20,-10, 10,-10, 30,-20,20,-20,40,-20,40,-10]
	function neg(a) {
	    a = [...a]
	    for(let i = 0; i < a.length; i += 2) a[i] = -a[i]
	    return a
	}
	a.rotate_array_callback(tail.rotate, base, quarter, 100, 150, 800)
	a.rotate_array_callback(tail.rotate, quarter, half, 150, 200, 800)
	a.rotate_array_callback(tail.rotate, half, full, 200, 300, 800)
	a.rotate_array_callback(tail.rotate, full, half, 300, 400, 800)
	a.rotate_array_callback(tail.rotate, half, quarter, 400, 450, 800)
	a.rotate_array_callback(tail.rotate, quarter, base, 450, 500, 800)
	quarter = neg(quarter)
	half = neg(half)
	full = neg(full)
	a.rotate_array_callback(tail.rotate, base, quarter, 500, 550, 800)
	a.rotate_array_callback(tail.rotate, quarter, half, 550, 600, 800)
	a.rotate_array_callback(tail.rotate, half, full, 600, 700, 800)
	a.rotate_array_callback(tail.rotate, full, half, 700, 800, 800)
	a.rotate_array_callback(tail.rotate, half, quarter, 800, 850, 800)
	a.rotate_array_callback(tail.rotate, quarter, base, 850, 900, 800)
    }
    a.start()
    return a
}

tail.to_basic = function(duration) {
    let a = new Animate4
    if(sitting) {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        0, duration)
    }
    else if(lying) {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
        0, duration)
    }
    else {
        a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        0, duration)
    }
    a.start()
    return a
}

tail.to_down = function(duration) {
    let a = new Animate4
    a.rotate_array_callback(tail.rotate,
        tail.current_angles,
        [0,90,0,20,0,30,0,30,0,30,0,30,0,10],
        0, duration)
    a.start()
    return a
}

function show_buttons() {
    document.getElementById('sit_stand_button').style.display = ''
    if(!sitting && !lying) {
	document.getElementById('go_stop_button').style.display = ''
        document.getElementById('run_button').style.display = ''
        document.getElementById('standup_button').style.display = ''
    }
    document.getElementById('tail_wag_button').style.display = ''
    if(sitting)
	document.getElementById('liedown_par').style.display = ''
    if(!lying)
	document.getElementById('paw_button').style.display = ''
}

function hide_buttons() {
    ['sit_stand_button', 'go_stop_button', 'tail_wag_button',
     'liedown_par', 'paw_button', 'run_button', 'standup_button'].forEach(function(id) {
	document.getElementById(id).style.display = 'none'
    })
}

window.animate_speed = 1
let go_animate
window.go_stop_button_click = function() {
    document.getElementById('paw_button').style.display = 'none'
    if(go_animate) {
	stop(go_animate)
	document.getElementById('go_stop_button').textContent = 'Пойдём!'
	go_animate = undefined
        document.getElementById('paw_button').style.display = ''
        document.getElementById('run_button').style.display = ''
	if(!tail_wag)
	    document.getElementById('stop_all_par').style.display = 'none'
    }
    else {
        if(tail_wag) {
            tail_wag.exit_now = true
            tail_wag = undefined
	    document.getElementById('tail_wag_button').textContent = ':)'
        }
	go_animate = go(window.animate_speed)
	document.getElementById('go_stop_button').textContent = 'Стой!'
	document.getElementById('stop_all_par').style.display = ''
    }
}

let tail_wag
window.tail_wag_button_click = function() {
    if(tail_wag) {
	tail_wag.exit_now = true
	tail.to_basic(100)
        document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
	if(!go_animate)
	    document.getElementById('stop_all_par').style.display = 'none'
    }
    else {
        tail_wag = tail.wag(window.animate_speed)
        document.getElementById('tail_wag_button').textContent = ':|'
	document.getElementById('stop_all_par').style.display = ''
    }
}

window.stop_all_button_click = function() {
    document.getElementById('stop_all_par').style.display = 'none'
    if(go_animate) {
	stop(go_animate)
	document.getElementById('go_stop_button').textContent = 'Пойдём!'
	go_animate = undefined
        document.getElementById('paw_button').style.display = ''
        document.getElementById('run_button').style.display = ''
    }
    if(tail_wag) {
	tail_wag.exit_now = true
	tail.to_basic(100)
	document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
    }
}

window.test_sit = function(sit) {
    if(sit) {
	body.rotate(55)
	rare.rotate(30)
	brpaw.rotate(30,0,135,0,30,-135,0,0,0)
	blpaw.rotate(-30,0,135,0,-30,-135,0,0,0)
	tail.rotate(0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0)
    }
    else {
	body.rotate(0)
	brpaw.rotate(0,0,0,0,0,0,0,0,0)
	blpaw.rotate(0,0,0,0,0,0,0,0,0)
	tail.rotate(0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30)
    }
}

window.sit = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(brpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,10,0,0,-35,0,0,20],
        100, 200)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,10,0,0,-35,0,0,20],
        [0,0,20,0,0,-55,0,0,20],
        200, 300)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,20,0,0,-55,0,0,20],
        [0,0,25,0,0,0,0,0,-25],
        300, 500)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,10,0,0,-35,0,0,20],
        500, 600)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,10,0,0,-35,0,0,20],
        [0,0,20,0,0,-55,0,0,20],
        600, 700)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,20,0,0,-55,0,0,20],
        [0,0,25,0,0,0,0,0,-25],
        700, 900)
    let first_body_rotate_call = true
    function body_rotate(angle_z) {
	if(first_body_rotate_call) {
	    first_body_rotate_call = false
	    body.calc_paw_bases()
	}
	body.rotate(angle_z)
    }
    a.rotate_array_callback(body_rotate, [0], [55], 900, 1500)
    a.rotate_array_callback(rare.rotate.bind(rare), [0], [30], 900, 1500)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [30,0,80,0,30,-100,0,0,0],
        900, 1150)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [-30,0,80,0,-30,-100,0,0,0],
        900, 1150)
    a.rotate_array_callback(brpaw.rotate,
        [30,0,80,0,30,-100,0,0,0],
        [30,0,135,0,30,-135,0,0,0],
        1150, 1500)
    a.rotate_array_callback(blpaw.rotate,
        [-30,0,80,0,-30,-100,0,0,0],
        [-30,0,135,0,-30,-135,0,0,0],
        1150, 1500)
    a.rotate_array_callback(tail.rotate,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        900, 1500)
    a.finish(function() {
	document.getElementById('sit_stand_button').textContent = 'Стоять'
	show_buttons()
    })
    a.start()
    return a
}

window.stand = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    if(lying) {
        lying = false
        function dog_mesh_position(y) { dog_mesh.position.y = y }
        a.rotate_array_callback(dog_mesh_position, [-4.8], [-2], 0, 500)
        a.rotate_array_callback(dog_mesh_position, [-2], [0], 500, 1100)
        a.rotate_array_callback(body.rotate.bind(body), [5], [0], 0, 600)
        a.rotate_array_callback(tail.rotate,
            [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
            [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
            0, 600)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,90,0,0,0,0,0,-50],
            [0,0,25,0,0,0,0,0,-25],
            0, 1100)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,90,0,0,0,0,0,-50],
            [0,0,25,0,0,0,0,0,-25],
            0, 1100)
        a.rotate_array_callback(brpaw.rotate,
            [30,-5,135,0,30,-110,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            0, 1000)
        a.rotate_array_callback(blpaw.rotate,
            [-30,-5,135,0,-30,-110,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            0, 1000)
    }
    else {
        sitting = false
        a.rotate_array_callback(body.rotate.bind(body), [55], [0], 0, 600)
        a.rotate_array_callback(rare.rotate.bind(rare), [30], [0], 0, 600)
        let first_rare_rotate_call = true
        function rare_rotate(angle_z) {
	    if(first_rare_rotate_call) {
	        first_rare_rotate_call = false
                rare.calc_tail_bases()
            }
	    rare.rotate(angle_z)
        }
        a.rotate_array_callback(tail.rotate,
            [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
            [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
            0, 600)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,10,0,0,-35,0,0,20],
            600, 700)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,10,0,0,-35,0,0,20],
            [0,0,20,0,0,-55,0,0,20],
            700, 800)
        a.rotate_array_callback(frpaw.rotate,
            [0,0,20,0,0,-55,0,0,20],
            [0,0,25,0,0,0,0,0,-25],
            800, 1000)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,10,0,0,-35,0,0,20],
            1000, 1100)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,10,0,0,-35,0,0,20],
            [0,0,20,0,0,-55,0,0,20],
            1100, 1200)
        a.rotate_array_callback(flpaw.rotate,
            [0,0,20,0,0,-55,0,0,20],
            [0,0,25,0,0,0,0,0,-25],
            1100, 1400)
        a.rotate_array_callback(brpaw.rotate,
            [30,0,135,0,30,-135,0,0,0],
            [30,0,80,0,30,-100,0,0,0],
            0, 350)
        a.rotate_array_callback(blpaw.rotate,
            [-30,0,135,0,-30,-135,0,0,0],
            [-30,0,80,0,-30,-100,0,0,0],
            0, 350)
        a.rotate_array_callback(brpaw.rotate,
            [30,0,80,0,30,-100,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            350, 600)
        a.rotate_array_callback(blpaw.rotate,
            [-30,0,80,0,-30,-100,0,0,0],
            [0,0,25,0,0,0,0,0,-25],
            350, 600)
    }
    // общее
    a.rotate_array_callback(frpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,25,0,0,0,0,0,-25],
        [0,0,0,0,0,0,0,0,0],
        1100, 1500)
    a.rotate_array_callback(function(x) {
        tiles.forEach(function(tile) {
            tile.m.position.x = tile.x + tile_delta_x - x
        })
    },
    [0], [3.42], 1100, 1500
    )
    a.finish(function() {
	document.getElementById('sit_stand_button').textContent = 'Сидеть'
	show_buttons()
    })
    a.start()
    return a
}

function stop_current(fincb) {
    if(go_animate) {
        stop(go_animate, fincb)
        go_animate = undefined
	document.getElementById('go_stop_button').textContent = 'Пойдём!'
        document.getElementById('stop_all_par').style.display = 'none'
    }
    else fincb()
    if(tail_wag) {
        tail_wag.exit_now = true
	tail.to_basic(100)
	document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
        document.getElementById('stop_all_par').style.display = 'none'
    }
}

window.sit_stand_button_click = function() {
    stop_current()
    hide_buttons();
    if(sitting || lying) {
	sitting = false
	stand(window.animate_speed)
    }
    else {
	sitting = true
	sit(window.animate_speed)
    }
}

window.liedown = function(tm) {
    lying = true
    sitting = false
    let a = new Animate4
    if(tm) a.time_modifier = tm
    function dog_mesh_position(y) { dog_mesh.position.y = y }
    a.rotate_array_callback(dog_mesh_position, [0], [-0.9], 0, 225)
    a.rotate_array_callback(dog_mesh_position, [-0.9], [-4.8], 225, 750)
    //a.rotate_array_callback(dog_mesh_position, [-3], [-4.8], 500, 800)
    a.rotate_array_callback(body.rotate.bind(body), [55], [5], 0, 750)
    a.rotate_array_callback(rare.rotate.bind(rare), [30], [0], 0, 750)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [30,0,135,0,30,-110,0,0,0],
        0, 750)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [-30,0,135,0,-30,-110,0,0,0],
        0, 750)
    a.rotate_array_callback(tail.rotate,
        [0,-40,0,0,0,0,0,0,-30,0,-40,0,-50,0],
        [0,90,0,20,0,-55,0,-10,0,-10,0,0,0,0],
        0, 750)
    a.rotate_array_callback(brpaw.rotate,
        [30,0,135,0,30,-110,0,0,0],
        [30,-5,135,0,30,-110,0,0,0],
        0, 1200)
    a.rotate_array_callback(blpaw.rotate,
        [-30,0,135,0,-30,-110,0,0,0],
        [-30,-5,135,0,-30,-110,0,0,0],
        0, 1200)
    a.rotate_array_callback(frpaw.rotate,
        [30,0,135,0,30,-110,0,0,0],
        [0,0,90,0,0,0,0,0,-50],
        800, 1400)
    a.rotate_array_callback(flpaw.rotate,
        [-30,0,135,0,-30,-110,0,0,0],
        [0,0,90,0,0,0,0,0,-50],
        800, 1400)
    a.start()
    a.finish(function() {
	show_buttons()
    })
    return a
}
window.liedown_button_click = function() {
    hide_buttons()
    liedown(window.animate_speed)
    if(tail_wag) {
        tail_wag.exit_now = true
	document.getElementById('tail_wag_button').textContent = ':)'
        tail_wag = undefined
        document.getElementById('stop_all_par').style.display = 'none'
    }
}

function btn_show_title(id, title) {
    let btn = document.getElementById(id)
    btn.textContent = title
    btn.style.display = ''
}

window.paw = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(frpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-60,0,0,0],
        0, 500)
    a.finish(function() {
	btn_show_title('paw_button', 'Опусти лапу')
    })
    a.start()
    return a
}
window.paw_down = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(frpaw.rotate,
        [0,0,90,0,0,-60,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        0, 500)
    a.finish(function() {
	show_buttons();
	btn_show_title('paw_button', 'Другую лапу')
    })
    a.start()
    return a
}
window.an_paw = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(flpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-60,0,0,0],
        0, 500)
    a.finish(function() {
	btn_show_title('paw_button', 'Опусти лапу')
    })
    a.start()
    return a
}
window.an_paw_down = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    a.rotate_array_callback(flpaw.rotate,
        [0,0,90,0,0,-60,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        0, 500)
    a.finish(function() {
	show_buttons();
	btn_show_title('paw_button', 'Лапу')
    })
    a.start()
    return a
}
window.paw_button_click = function() {
    hide_buttons()
    document.getElementById('tail_wag_button').style.display = ''
    if(!paw_up && !left_paw) {
        paw_up = true
        paw(window.animate_speed)
    }
    else if(paw_up && !left_paw) {
	paw_up = false
	left_paw = true
        paw_down(window.animate_speed)
    }
    else if(!paw_up && left_paw) {
        paw_up = true
        an_paw(window.animate_speed)
    }
    else { // if(paw_up && left_paw) {
	paw_up = false
	left_paw = false
        an_paw_down(window.animate_speed)
    }
}

window.run = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let period = 1000
    let front = function(paw) {
        a.rotate_array_callback(paw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,60,0,0,-110,0,0,0],
            0, 200)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,-110,0,0,0],
            [0,0,60,0,0,0,0,0,-30],
            200, 500)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,0,0,0,-30],
            [0,0,-30,0,0,0,0,0,0],
            500, 1000)
        a.rotate_array_callback(paw.rotate,
            [0,0,-30,0,0,0,0,0,0],
            [0,0,60,0,0,-110,0,0,0],
            1000, 1200, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,-110,0,0,0],
            [0,0,60,0,0,0,0,0,-30],
            1200, 1500, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,60,0,0,0,0,0,-30],
            [0,0,-30,0,0,0,0,0,0],
            1500, 2000, period)
    }
    front(frpaw)
    front(flpaw)
    let back = function(paw) {
        a.rotate_array_callback(paw.rotate,
            [0,0,0,0,0,0,0,0,0],
            [0,0,-60,0,0,-20,0,0,0],
            0, 500)
        a.rotate_array_callback(paw.rotate,
            [0,0,-60,0,0,-20,0,0,0],
            [0,0,-15,0,0,-80,0,0,0],
            500, 700)
        a.rotate_array_callback(paw.rotate,
            [0,0,-15,0,0,-80,0,0,0],
            [0,0,30,0,0,-20,0,0,0],
            700, 1000)
        a.rotate_array_callback(paw.rotate,
            [0,0,30,0,0,-20,0,0,0],
            [0,0,-60,0,0,-20,0,0,0],
            1000, 1500, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,-60,0,0,-20,0,0,0],
            [0,0,-15,0,0,-80,0,0,0],
            1500, 1700, period)
        a.rotate_array_callback(paw.rotate,
            [0,0,-15,0,0,-80,0,0,0],
            [0,0,30,0,0,-20,0,0,0],
            1700, 2000, period)
    }
    back(brpaw)
    back(blpaw)
    a.rotate_array_callback(tail.rotate,
        [0,8,0,-9,0,-25,0,-20,0,-45,0,-45,0,-30],
        [0,20,0,20,0,-20,0,20,0,-20,0,20,0,-20],
        0, 500)
    a.rotate_array_callback(tail.rotate,
        [0,20,0,20,0,-20,0,20,0,-20,0,20,0,-20],
        [0,10,0,17,0,-23,0,17,0,-23,0,17,0,-23],
        500, 1000, period)
    a.rotate_array_callback(tail.rotate,
        [0,10,0,17,0,-23,0,17,0,-23,0,17,0,-23],
        [0,20,0,20,0,-20,0,20,0,-20,0,20,0,-20],
        1000, 1500, period)
    let tile_start = 0
    let tile_period = 417.68
    a.rotate_array_callback(function(x) {
        tiles.forEach(function(tile) {
            tile.m.position.x = tile.x + tile_delta_x - x
        })
    },
    [0], [6], tile_start, tile_start + tile_period, tile_period
    )
    a.rotate_array_callback(dog_updown, [0], [1], 0, 500, 1000)
    a.rotate_array_callback(dog_updown, [1], [0], 500, 1000, 1000)
    a.finish(function() {
    })
    a.finish(function() {
	show_buttons();
    })
    a.start()
    return a
}

window.run_button_click = function() {
    if(go_animate) go_animate.exit_now = true
    go_animate = run()
    document.getElementById('go_stop_button').textContent = 'Стой!'
    document.getElementById('stop_all_par').style.display = ''
    document.getElementById('run_button').style.display = 'none'
    document.getElementById('paw_button').style.display = 'none'
}

window.standup = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    let delta_x = dog_mesh.geometry.attributes.position.array[376*3+0]
    let delta_y = dog_mesh.geometry.attributes.position.array[376*3+1]
    function dog_mesh_position() {
	dog_mesh.position.x = delta_x -
	    dog_mesh.geometry.attributes.position.array[376*3+0]
	dog_mesh.position.y = delta_y -
	    dog_mesh.geometry.attributes.position.array[376*3+1]
    }
    a.rotate_array_callback(dog_mesh_position, [], [], 0, 2000)
    // function dog_mesh_position_x(x) { dog_mesh.position.x = x }
    // a.rotate_array_callback(dog_mesh_position_x, [0], [-2], 200, 500)
    a.rotate_array_callback(body.rotate.bind(body), [0], [60], 0, 500)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,-10,0,0,0,0,0,0],
        0, 500)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,-10,0,0,0,0,0,0],
        0, 500)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-90,0,0,0],
        0, 500)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,0,0,0,0,0,0,0],
        [0,0,90,0,0,-90,0,0,0],
        0, 500)
    let base    = [  0,8, 0, -9,  0,-25,  0,-20, 0,-45, 0,-45, 0,-30]
    let quarter = [2.5,8, 5, -9,2.5,-25,7.5,-20, 5,-45,10,-40,10,-27]
    let half    = [  5,8,10, -9,  5,-25, 15,-20,10,-45,20,-30,20,-20]
    let full    = [ 10,0,20,-10, 10,-10, 30,-20,20,-20,40,-20,40,-10]
    function neg(a) {
        a = [...a]
        for(let i = 0; i < a.length; i += 2) a[i] = -a[i]
        return a
    }
    a.rotate_array_callback(tail.rotate, base, quarter, 500, 550)
    a.rotate_array_callback(tail.rotate, quarter, half, 550, 600)
    a.rotate_array_callback(tail.rotate, half, full, 600, 700)
    a.rotate_array_callback(tail.rotate, full, half, 700, 800)
    a.rotate_array_callback(tail.rotate, half, quarter, 800, 850)
    a.rotate_array_callback(tail.rotate, quarter, base, 850, 900)
    quarter = neg(quarter)
    half = neg(half)
    full = neg(full)
    a.rotate_array_callback(tail.rotate, base, quarter, 900, 950)
    a.rotate_array_callback(tail.rotate, quarter, half, 950, 1000)
    a.rotate_array_callback(tail.rotate, half, full, 1000, 1100)
    a.rotate_array_callback(tail.rotate, full, half, 1100, 1200)
    a.rotate_array_callback(tail.rotate, half, quarter, 1200, 1250)
    a.rotate_array_callback(tail.rotate, quarter, base, 1250, 1300)
    // down
    // function dog_mesh_position_y(y) { dog_mesh.position.y = y }
    // a.rotate_array_callback(dog_mesh_position_y, [5.5], [0], 1500, 2000)
    // function dog_mesh_position_x(x) { dog_mesh.position.x = x }
    // a.rotate_array_callback(dog_mesh_position_x, [-2], [0], 1500, 2000)
    a.rotate_array_callback(body.rotate.bind(body), [60], [0], 1500, 2000)
    a.rotate_array_callback(brpaw.rotate,
        [0,0,-10,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.rotate_array_callback(blpaw.rotate,
        [0,0,-10,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.rotate_array_callback(frpaw.rotate,
        [0,0,90,0,0,-90,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.rotate_array_callback(flpaw.rotate,
        [0,0,90,0,0,-90,0,0,0],
        [0,0,0,0,0,0,0,0,0],
        1500, 2000)
    a.finish(function() {
	show_buttons();
    })
    a.start()
    return a
}

window.standup_button_click = function() {
    stop_current(standup)
    hide_buttons()
}

window.turn = function(tm) {
    let a = new Animate4
    if(tm) a.time_modifier = tm
    //a.rotate_array_callback(body.rotate.bind(body), [0], [180], 0, 500) -как повернуть тело по другой оси???
    function dog_mesh_position(y) { dog_mesh.position.y = y }
    a.rotate_array_callback(dog_mesh_position, [0], [-5], 0, 500)
    a.finish(function() {
	show_buttons();
    })
    a.start()
    return a
}

  </script>
  <div align="center" style="position:absolute;right:10px">
    <p><button id="go_stop_button" onclick="go_stop_button_click()">Пойдём!</button></p>
    <p><button id="run_button" onclick="run_button_click()">Побежали!</button></p>
    <p><button id="tail_wag_button" onclick="tail_wag_button_click()">:)</button></p>
    <p id="stop_all_par" style="display:none"><button id="stop_all_button" onclick="stop_all_button_click()">Замри!</button></p>
    <p><button id="sit_stand_button" onclick="sit_stand_button_click()">Сидеть</button></p>
    <p id="liedown_par" style="display:none"><button id="liedown_button" onclick="liedown_button_click()">Лежать</button></p>
    <p><button id="paw_button" onclick="paw_button_click()">Лапу</button></p>
    <p><button id="standup_button" onclick="standup_button_click()">Вверх!</button></p>
  </div>
</body>
</html>
